#!/bin/bash
#
# PITR Timestamp Finder
# Scans MySQL binlogs to find the timestamp just before a destructive operation
# (DROP/DELETE/TRUNCATE) for use with pxc-restore point-in-time recovery.
#
# This script is READ-ONLY - it only examines binlogs to find a timestamp.
# No data is modified.
#

set -euo pipefail

# Configuration
KUBECONFIG="${KUBECONFIG:-}"
NAMESPACE=""
POD_NAME=""
OPERATION=""
TABLE_NAME=""
DATABASE_NAME=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_header() {
    echo ""
    echo -e "${CYAN}=====================================================${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}=====================================================${NC}"
    echo ""
}

# Wraps kubectl with optional custom kubeconfig
kctl() {
    if [ -n "$KUBECONFIG" ]; then
        kubectl --kubeconfig="$KUBECONFIG" "$@"
    else
        kubectl "$@"
    fi
}

usage() {
    cat << EOF
PITR Timestamp Finder

Scans MySQL binlogs to find the timestamp just before a destructive operation
(DROP/DELETE/TRUNCATE) for use with pxc-restore point-in-time recovery.

USAGE:
    $0 -n NAMESPACE [OPTIONS]

REQUIRED:
    -n, --namespace NAMESPACE   Namespace containing the PXC cluster

OPTIONS:
    -p, --pod POD               PXC pod name (auto-detected if only one cluster)
    -o, --operation TYPE        Destructive operation: DROP, DELETE, TRUNCATE
    -d, --database DATABASE     Database name (optional, narrows search)
    -t, --table TABLE           Table name to search for
    --kubeconfig PATH           Path to kubeconfig file
    -h, --help                  Show this help message

EXAMPLES:
    # Interactive mode - prompts for all inputs
    $0 -n percona

    # Specify operation and table
    $0 -n percona -o DROP -d mydb -t users

    # Specify exact pod
    $0 -n percona -p db-pxc-0 -o DELETE -t orders

OUTPUT:
    Outputs a timestamp in the format required by pxc-restore:
    YYYY-MM-DD HH:MM:SS (UTC)

    This timestamp represents the moment just BEFORE the destructive operation
    occurred, suitable for point-in-time recovery.

NOTE:
    This script is READ-ONLY. It only examines binlogs and makes no changes.
EOF
    exit 0
}

# Find PXC pod in namespace
find_pxc_pod() {
    local ns="$1"
    local pod=""
    
    # Try to find a running PXC pod
    pod=$(kctl get pods -n "$ns" -l "app.kubernetes.io/component=pxc" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null) || pod=""
    
    if [ -z "$pod" ]; then
        # Fallback: find pod with pxc in name
        pod=$(kctl get pods -n "$ns" --no-headers 2>/dev/null | grep -E "pxc-[0-9]" | grep "Running" | head -1 | awk '{print $1}') || pod=""
    fi
    
    echo "$pod"
}

# Get list of binlog files from MySQL
get_binlog_list() {
    local ns="$1"
    local pod="$2"
    
    kctl exec -n "$ns" "$pod" -c pxc -- mysql -N -e "SHOW BINARY LOGS;" 2>/dev/null | awk '{print $1}'
}

# Get binlog directory path
get_binlog_dir() {
    local ns="$1"
    local pod="$2"
    
    local binlog_dir
    binlog_dir=$(kctl exec -n "$ns" "$pod" -c pxc -- mysql -N -e "SELECT @@log_bin_basename;" 2>/dev/null | xargs dirname 2>/dev/null) || binlog_dir=""
    
    if [ -z "$binlog_dir" ] || [ "$binlog_dir" = "." ]; then
        # Default MySQL data directory
        binlog_dir="/var/lib/mysql"
    fi
    
    echo "$binlog_dir"
}

# Get timestamp range from a binlog file
get_binlog_timestamps() {
    local ns="$1"
    local pod="$2"
    local binlog="$3"
    local binlog_dir="$4"
    
    local binlog_path="${binlog_dir}/${binlog}"
    
    # Get first and last timestamps from binlog
    # Use mysqlbinlog with --start-datetime far in past and --stop-datetime far in future
    # to capture all events, then extract timestamps
    local output
    output=$(kctl exec -n "$ns" "$pod" -c pxc -- mysqlbinlog --base64-output=DECODE-ROWS "$binlog_path" 2>/dev/null | grep -E "^#[0-9]{6}" | head -1) || output=""
    
    local first_ts=""
    if [ -n "$output" ]; then
        # Format: #241215 14:30:00 -> 2024-12-15 14:30:00
        first_ts=$(echo "$output" | sed -E 's/^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2}).*/20\1-\2-\3 \4/')
    fi
    
    local last_output
    last_output=$(kctl exec -n "$ns" "$pod" -c pxc -- mysqlbinlog --base64-output=DECODE-ROWS "$binlog_path" 2>/dev/null | grep -E "^#[0-9]{6}" | tail -1) || last_output=""
    
    local last_ts=""
    if [ -n "$last_output" ]; then
        last_ts=$(echo "$last_output" | sed -E 's/^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2}).*/20\1-\2-\3 \4/')
    fi
    
    echo "${first_ts}|${last_ts}"
}

# Search binlog for destructive operation and return timestamp just before it
search_binlog_for_operation() {
    local ns="$1"
    local pod="$2"
    local binlog="$3"
    local binlog_dir="$4"
    local operation="$5"
    local table="$6"
    local database="${7:-}"
    
    local binlog_path="${binlog_dir}/${binlog}"
    
    # Build search pattern
    local pattern=""
    case "$operation" in
        DROP)
            if [ -n "$database" ]; then
                pattern="DROP[[:space:]]+TABLE.*\`?${database}\`?\.\`?${table}\`?"
            else
                pattern="DROP[[:space:]]+TABLE.*\`?${table}\`?"
            fi
            ;;
        DELETE)
            if [ -n "$database" ]; then
                pattern="DELETE[[:space:]]+FROM[[:space:]]+\`?${database}\`?\.\`?${table}\`?"
            else
                pattern="DELETE[[:space:]]+FROM[[:space:]]+\`?${table}\`?"
            fi
            ;;
        TRUNCATE)
            if [ -n "$database" ]; then
                pattern="TRUNCATE[[:space:]]+(TABLE[[:space:]]+)?\`?${database}\`?\.\`?${table}\`?"
            else
                pattern="TRUNCATE[[:space:]]+(TABLE[[:space:]]+)?\`?${table}\`?"
            fi
            ;;
    esac
    
    # Parse binlog and find the operation
    # We need to track the timestamp of each event and return the one just before the match
    local result
    result=$(kctl exec -n "$ns" "$pod" -c pxc -- bash -c "
        mysqlbinlog --base64-output=DECODE-ROWS -v '${binlog_path}' 2>/dev/null | awk '
        BEGIN { 
            prev_ts = \"\"
            current_ts = \"\"
            found = 0
        }
        /^#[0-9]{6}/ {
            # Extract timestamp: #241215 14:30:00 -> 2024-12-15 14:30:00
            match(\$0, /^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2})/, arr)
            if (arr[1] != \"\") {
                prev_ts = current_ts
                current_ts = \"20\" arr[1] \"-\" arr[2] \"-\" arr[3] \" \" arr[4]
            }
        }
        /${pattern}/i {
            if (!found && prev_ts != \"\") {
                print prev_ts
                found = 1
                exit
            } else if (!found && current_ts != \"\") {
                # If we matched on first event, use the current timestamp minus 1 second
                print current_ts
                found = 1
                exit
            }
        }
        END {
            if (!found) {
                print \"NOT_FOUND\"
            }
        }
        '
    " 2>/dev/null) || result="ERROR"
    
    echo "$result"
}

# Subtract one second from a timestamp
subtract_one_second() {
    local ts="$1"
    
    # Use date command to subtract one second
    # Input: YYYY-MM-DD HH:MM:SS
    if command -v gdate &>/dev/null; then
        # macOS with GNU coreutils
        gdate -d "${ts} UTC - 1 second" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
    elif date --version 2>&1 | grep -q GNU; then
        # GNU date (Linux)
        date -d "${ts} UTC - 1 second" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
    else
        # BSD date (macOS default) - convert to epoch, subtract, convert back
        local epoch
        epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$ts" "+%s" 2>/dev/null) || epoch=""
        if [ -n "$epoch" ]; then
            epoch=$((epoch - 1))
            date -j -f "%s" "$epoch" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
        else
            echo "$ts"
        fi
    fi
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -p|--pod)
            POD_NAME="$2"
            shift 2
            ;;
        -o|--operation)
            OPERATION="$2"
            shift 2
            ;;
        -d|--database)
            DATABASE_NAME="$2"
            shift 2
            ;;
        -t|--table)
            TABLE_NAME="$2"
            shift 2
            ;;
        --kubeconfig)
            KUBECONFIG="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            echo ""
            usage
            ;;
    esac
done

# Validate namespace
if [ -z "$NAMESPACE" ]; then
    log_error "Namespace is required. Use -n or --namespace."
    echo ""
    usage
fi

log_header "PITR Timestamp Finder"

log_info "This script helps find the timestamp just before a destructive operation"
log_info "for use with pxc-restore point-in-time recovery."
echo ""
log_warn "This is a READ-ONLY operation - no data will be modified."
echo ""

# Find or validate PXC pod
if [ -z "$POD_NAME" ]; then
    log_info "Finding PXC pod in namespace: $NAMESPACE"
    POD_NAME=$(find_pxc_pod "$NAMESPACE")
    
    if [ -z "$POD_NAME" ]; then
        log_error "No PXC pod found in namespace: $NAMESPACE"
        exit 1
    fi
    log_success "Found PXC pod: $POD_NAME"
else
    # Validate provided pod exists
    if ! kctl get pod "$POD_NAME" -n "$NAMESPACE" &>/dev/null; then
        log_error "Pod not found: $POD_NAME in namespace $NAMESPACE"
        exit 1
    fi
    log_success "Using pod: $POD_NAME"
fi

# Get destructive operation type if not provided
if [ -z "$OPERATION" ]; then
    echo ""
    echo "Select the destructive operation to search for:"
    echo "  [1] DROP TABLE"
    echo "  [2] DELETE FROM"
    echo "  [3] TRUNCATE TABLE"
    echo ""
    read -p "Enter selection [1-3]: " op_choice
    
    case "$op_choice" in
        1) OPERATION="DROP" ;;
        2) OPERATION="DELETE" ;;
        3) OPERATION="TRUNCATE" ;;
        *)
            log_error "Invalid selection"
            exit 1
            ;;
    esac
fi

# Validate and normalize operation
OPERATION=$(echo "$OPERATION" | tr '[:lower:]' '[:upper:]')
case "$OPERATION" in
    DROP|DELETE|TRUNCATE) ;;
    *)
        log_error "Invalid operation: $OPERATION. Must be DROP, DELETE, or TRUNCATE."
        exit 1
        ;;
esac

log_success "Searching for: $OPERATION"

# Get database name if not provided (optional)
if [ -z "$DATABASE_NAME" ]; then
    echo ""
    read -p "Enter database name (optional, press Enter to skip): " DATABASE_NAME
    if [ -n "$DATABASE_NAME" ]; then
        log_info "Filtering by database: $DATABASE_NAME"
    fi
fi

# Get table name if not provided
if [ -z "$TABLE_NAME" ]; then
    echo ""
    read -p "Enter table name: " TABLE_NAME
    
    if [ -z "$TABLE_NAME" ]; then
        log_error "Table name is required"
        exit 1
    fi
fi

log_success "Searching for table: $TABLE_NAME"

echo ""
log_header "Scanning Binlogs"

# Get binlog directory
BINLOG_DIR=$(get_binlog_dir "$NAMESPACE" "$POD_NAME")
log_info "Binlog directory: $BINLOG_DIR"

# Get list of binlogs (newest first)
BINLOG_LIST=$(get_binlog_list "$NAMESPACE" "$POD_NAME")

if [ -z "$BINLOG_LIST" ]; then
    log_error "No binlogs found. Binary logging may not be enabled."
    exit 1
fi

# Convert to array and reverse (newest first)
mapfile -t BINLOGS <<< "$BINLOG_LIST"
BINLOG_COUNT=${#BINLOGS[@]}
log_info "Found $BINLOG_COUNT binlog file(s)"

# Iterate through binlogs from newest to oldest
FOUND_TIMESTAMP=""
for ((i = BINLOG_COUNT - 1; i >= 0; i--)); do
    binlog="${BINLOGS[$i]}"
    
    echo ""
    log_info "Examining binlog: $binlog ($(($BINLOG_COUNT - $i)) of $BINLOG_COUNT from newest)"
    
    # Get timestamp range
    timestamps=$(get_binlog_timestamps "$NAMESPACE" "$POD_NAME" "$binlog" "$BINLOG_DIR")
    first_ts="${timestamps%%|*}"
    last_ts="${timestamps##*|}"
    
    if [ -z "$first_ts" ] || [ -z "$last_ts" ]; then
        log_warn "  Could not read timestamps from this binlog, skipping..."
        continue
    fi
    
    echo ""
    echo "  Binlog time range:"
    echo -e "    ${CYAN}Earliest:${NC} $first_ts"
    echo -e "    ${CYAN}Latest:${NC}   $last_ts"
    echo ""
    
    # Ask user if the destructive action was between these timestamps
    read -p "  Was the $OPERATION on '$TABLE_NAME' between these times? [y/n/q]: " confirm
    
    case "$confirm" in
        [Yy]*)
            # Search this binlog for the operation
            log_info "  Searching for $OPERATION operation on '$TABLE_NAME'..."
            
            result=$(search_binlog_for_operation "$NAMESPACE" "$POD_NAME" "$binlog" "$BINLOG_DIR" "$OPERATION" "$TABLE_NAME" "$DATABASE_NAME")
            
            if [ "$result" = "NOT_FOUND" ]; then
                log_warn "  Operation not found in this binlog."
                read -p "  Try previous binlog? [y/n]: " try_prev
                if [[ ! "$try_prev" =~ ^[Yy]$ ]]; then
                    log_info "Exiting without finding timestamp."
                    exit 0
                fi
                continue
            elif [ "$result" = "ERROR" ]; then
                log_error "  Error reading binlog"
                continue
            else
                # Found it! Subtract one second to get the safe restore point
                FOUND_TIMESTAMP=$(subtract_one_second "$result")
                break
            fi
            ;;
        [Qq]*)
            log_info "Exiting."
            exit 0
            ;;
        *)
            # Not in this binlog, continue to previous
            log_info "  Continuing to previous binlog..."
            continue
            ;;
    esac
done

echo ""

if [ -z "$FOUND_TIMESTAMP" ]; then
    log_error "Could not find the $OPERATION operation in any binlog."
    log_info "Possible reasons:"
    log_info "  - The operation occurred before the oldest available binlog"
    log_info "  - The table name or database name doesn't match exactly"
    log_info "  - Binary logging was not enabled at the time"
    exit 1
fi

log_header "Result"

echo -e "  ${GREEN}${BOLD}Found timestamp for PITR restore:${NC}"
echo ""
echo -e "  ${CYAN}${BOLD}$FOUND_TIMESTAMP${NC}"
echo ""
echo "  This timestamp represents the moment just BEFORE the $OPERATION operation."
echo "  Use this timestamp with pxc-restore for point-in-time recovery:"
echo ""
echo -e "  ${YELLOW}pxc-restore -n $NAMESPACE -t <target-namespace> -r \"$FOUND_TIMESTAMP\"${NC}"
echo ""
log_success "Done."

