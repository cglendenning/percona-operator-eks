#!/bin/bash
#
# PITR Timestamp Finder
# Scans MySQL binlogs to find the timestamp just before a destructive operation
# (DROP/DELETE/TRUNCATE) for use with pxc-restore point-in-time recovery.
#
# This script is READ-ONLY - it only examines binlogs to find a timestamp.
# No data is modified.
#

set -euo pipefail

# Configuration
KUBECONFIG="${KUBECONFIG:-}"
NAMESPACE=""
POD_NAME=""
OPERATION=""
TABLE_NAME=""
DATABASE_NAME=""
SCAN_ALL_PODS=false
MYSQL_ROOT_PASSWORD=""
CLUSTER_NAME=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Logging functions - all go to stderr so they display when stdout is captured
log_info() { echo -e "${BLUE}[INFO]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[OK]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_header() {
    echo "" >&2
    echo -e "${CYAN}=====================================================${NC}" >&2
    echo -e "${CYAN}  $1${NC}" >&2
    echo -e "${CYAN}=====================================================${NC}" >&2
    echo "" >&2
}

# Echo to stderr (for use in functions whose stdout is captured)
echo_err() { echo -e "$@" >&2; }

# Wraps kubectl with optional custom kubeconfig
kctl() {
    if [ -n "$KUBECONFIG" ]; then
        kubectl --kubeconfig="$KUBECONFIG" "$@"
    else
        kubectl "$@"
    fi
}

usage() {
    cat << EOF
PITR Timestamp Finder

Scans MySQL binlogs to find the timestamp just before a destructive operation
(DROP/DELETE/TRUNCATE) for use with pxc-restore point-in-time recovery.

USAGE:
    $0 -n NAMESPACE [OPTIONS]

REQUIRED:
    -n, --namespace NAMESPACE   Namespace containing the PXC cluster

OPTIONS:
    -p, --pod POD               PXC pod name (will prompt to select if not provided)
    -a, --all-pods              Scan all PXC pods (useful if primary changed)
    -o, --operation TYPE        Destructive operation: DROP, DELETE, TRUNCATE
    -d, --database DATABASE     Database name (optional, narrows search)
    -t, --table TABLE           Table name to search for
    --kubeconfig PATH           Path to kubeconfig file
    -h, --help                  Show this help message

EXAMPLES:
    # Interactive mode - prompts for all inputs
    $0 -n percona

    # Scan all pods (recommended if unsure which was primary)
    $0 -n percona --all-pods -o DROP -t users

    # Specify operation and table
    $0 -n percona -o DROP -d mydb -t users

    # Specify exact pod
    $0 -n percona -p db-pxc-0 -o DELETE -t orders

OUTPUT:
    Outputs a timestamp in the format required by pxc-restore:
    YYYY-MM-DD HH:MM:SS (UTC)

    This timestamp represents the moment just BEFORE the destructive operation
    occurred, suitable for point-in-time recovery.

PXC CLUSTER NOTE:
    In a PXC cluster, each node has its own binlogs. If a primary failover
    occurred, the destructive operation may be in a different pod's binlogs.
    Use --all-pods to scan all pods, or specify -p to target a specific pod.

NOTE:
    This script is READ-ONLY. It only examines binlogs and makes no changes.
EOF
    exit 0
}

# Get all PXC pods in namespace
get_pxc_pods() {
    local ns="$1"
    local pods=""
    
    # Try to find running PXC pods by label
    pods=$(kctl get pods -n "$ns" -l "app.kubernetes.io/component=pxc" --field-selector=status.phase=Running -o jsonpath='{.items[*].metadata.name}' 2>/dev/null) || pods=""
    
    if [ -z "$pods" ]; then
        # Fallback: find pods with pxc in name
        pods=$(kctl get pods -n "$ns" --no-headers 2>/dev/null | grep -E "pxc-[0-9]" | grep "Running" | awk '{print $1}' | tr '\n' ' ') || pods=""
    fi
    
    echo "$pods"
}

# Get the PXC cluster name from namespace
get_cluster_name() {
    local ns="$1"
    kctl get perconaxtradbcluster -n "$ns" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo ""
}

# Get MySQL root password from cluster secrets
get_mysql_root_password() {
    local ns="$1"
    local cluster="$2"
    
    # First, check what secretsName the cluster uses
    local secrets_name
    secrets_name=$(kctl get perconaxtradbcluster "$cluster" -n "$ns" -o jsonpath='{.spec.secretsName}' 2>/dev/null) || secrets_name=""
    
    if [ -z "$secrets_name" ]; then
        # Try common naming conventions
        secrets_name="${cluster}-secrets"
    fi
    
    # Get the root password from the secret
    local root_pwd_b64
    root_pwd_b64=$(kctl get secret "$secrets_name" -n "$ns" -o jsonpath='{.data.root}' 2>/dev/null) || root_pwd_b64=""
    
    if [ -z "$root_pwd_b64" ]; then
        # Try alternate secret name patterns
        for try_secret in "${cluster}-secrets" "internal-${cluster}" "${cluster}-pxc-secrets"; do
            root_pwd_b64=$(kctl get secret "$try_secret" -n "$ns" -o jsonpath='{.data.root}' 2>/dev/null) || root_pwd_b64=""
            if [ -n "$root_pwd_b64" ]; then
                break
            fi
        done
    fi
    
    if [ -n "$root_pwd_b64" ]; then
        echo "$root_pwd_b64" | base64 -d 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Get list of binlog files from MySQL
get_binlog_list() {
    local ns="$1"
    local pod="$2"
    local password="$3"
    
    local result
    result=$(kctl exec -n "$ns" "$pod" -c pxc -- mysql -uroot -p"${password}" -N -e "SHOW BINARY LOGS;" 2>/dev/null) || result=""
    
    if [ -n "$result" ]; then
        echo "$result" | awk '{print $1}'
    fi
}

# Get binlog directory path
get_binlog_dir() {
    local ns="$1"
    local pod="$2"
    local password="$3"
    
    local binlog_dir
    binlog_dir=$(kctl exec -n "$ns" "$pod" -c pxc -- mysql -uroot -p"${password}" -N -e "SELECT @@log_bin_basename;" 2>/dev/null | xargs dirname 2>/dev/null) || binlog_dir=""
    
    if [ -z "$binlog_dir" ] || [ "$binlog_dir" = "." ]; then
        # Default MySQL data directory
        binlog_dir="/var/lib/mysql"
    fi
    
    echo "$binlog_dir"
}

# Get timestamp range from a binlog file
get_binlog_timestamps() {
    local ns="$1"
    local pod="$2"
    local binlog="$3"
    local binlog_dir="$4"
    
    local binlog_path="${binlog_dir}/${binlog}"
    
    # Get first and last timestamps from binlog
    local output
    output=$(kctl exec -n "$ns" "$pod" -c pxc -- mysqlbinlog --base64-output=DECODE-ROWS "$binlog_path" 2>/dev/null | grep -E "^#[0-9]{6}" | head -1) || output=""
    
    local first_ts=""
    if [ -n "$output" ]; then
        # Format: #241215 14:30:00 -> 2024-12-15 14:30:00
        first_ts=$(echo "$output" | sed -E 's/^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2}).*/20\1-\2-\3 \4/')
    fi
    
    local last_output
    last_output=$(kctl exec -n "$ns" "$pod" -c pxc -- mysqlbinlog --base64-output=DECODE-ROWS "$binlog_path" 2>/dev/null | grep -E "^#[0-9]{6}" | tail -1) || last_output=""
    
    local last_ts=""
    if [ -n "$last_output" ]; then
        last_ts=$(echo "$last_output" | sed -E 's/^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2}).*/20\1-\2-\3 \4/')
    fi
    
    echo "${first_ts}|${last_ts}"
}

# Search binlog for destructive operation and return timestamp just before it
# Returns: "TIMESTAMP|||MATCHED_STATEMENT" or "NOT_FOUND" or "ERROR"
search_binlog_for_operation() {
    local ns="$1"
    local pod="$2"
    local binlog="$3"
    local binlog_dir="$4"
    local operation="$5"
    local table="$6"
    local database="${7:-}"
    
    local binlog_path="${binlog_dir}/${binlog}"
    
    # Build search pattern - escape special regex characters in table/database names
    # Use word boundaries to avoid partial matches
    local escaped_table
    local escaped_database
    escaped_table=$(printf '%s' "$table" | sed 's/[[\.*^$()+?{|]/\\&/g')
    escaped_database=""
    if [ -n "$database" ]; then
        escaped_database=$(printf '%s' "$database" | sed 's/[[\.*^$()+?{|]/\\&/g')
    fi
    
    # Build pattern that requires the table name to be a complete word (with backticks or word boundaries)
    local pattern=""
    case "$operation" in
        DROP)
            if [ -n "$escaped_database" ]; then
                # Match: DROP TABLE `db`.`table` or DROP TABLE db.table
                pattern="DROP[[:space:]]+TABLE[[:space:]]+(IF[[:space:]]+EXISTS[[:space:]]+)?(\`${escaped_database}\`|${escaped_database})\\.(\`${escaped_table}\`|${escaped_table})"
            else
                # Match: DROP TABLE `table` or DROP TABLE table (with word boundary)
                pattern="DROP[[:space:]]+TABLE[[:space:]]+(IF[[:space:]]+EXISTS[[:space:]]+)?(\`${escaped_table}\`|[^.\`]*[[:space:]\`]${escaped_table}[[:space:]\`\$])"
            fi
            ;;
        DELETE)
            if [ -n "$escaped_database" ]; then
                pattern="DELETE[[:space:]]+FROM[[:space:]]+(\`${escaped_database}\`|${escaped_database})\\.(\`${escaped_table}\`|${escaped_table})"
            else
                pattern="DELETE[[:space:]]+FROM[[:space:]]+(\`${escaped_table}\`|${escaped_table})([[:space:]]|\$|;)"
            fi
            ;;
        TRUNCATE)
            if [ -n "$escaped_database" ]; then
                pattern="TRUNCATE[[:space:]]+(TABLE[[:space:]]+)?(\`${escaped_database}\`|${escaped_database})\\.(\`${escaped_table}\`|${escaped_table})"
            else
                pattern="TRUNCATE[[:space:]]+(TABLE[[:space:]]+)?(\`${escaped_table}\`|${escaped_table})([[:space:]]|\$|;)"
            fi
            ;;
    esac
    
    log_info "    Pattern: $pattern"
    
    # Parse binlog and find the operation
    # Returns: timestamp|||matched_line
    local result
    result=$(kctl exec -n "$ns" "$pod" -c pxc -- bash -c "
        mysqlbinlog --base64-output=DECODE-ROWS -v '${binlog_path}' 2>/dev/null | awk '
        BEGIN { 
            prev_ts = \"\"
            current_ts = \"\"
            found = 0
        }
        /^#[0-9]{6}/ {
            # Extract timestamp: #241215 14:30:00 -> 2024-12-15 14:30:00
            match(\$0, /^#([0-9]{2})([0-9]{2})([0-9]{2}) +([0-9]{2}:[0-9]{2}:[0-9]{2})/, arr)
            if (arr[1] != \"\") {
                prev_ts = current_ts
                current_ts = \"20\" arr[1] \"-\" arr[2] \"-\" arr[3] \" \" arr[4]
            }
        }
        /${pattern}/i {
            if (!found) {
                ts_to_use = prev_ts
                if (ts_to_use == \"\") {
                    ts_to_use = current_ts
                }
                # Print timestamp and the matched line, separated by |||
                # Truncate matched line to first 200 chars for safety
                matched = substr(\$0, 1, 200)
                gsub(/\n/, \" \", matched)
                print ts_to_use \"|||\" matched
                found = 1
                exit
            }
        }
        END {
            if (!found) {
                print \"NOT_FOUND\"
            }
        }
        '
    " 2>/dev/null) || result="ERROR"
    
    echo "$result"
}

# Subtract one second from a timestamp
subtract_one_second() {
    local ts="$1"
    
    # Use date command to subtract one second
    # Input: YYYY-MM-DD HH:MM:SS
    if command -v gdate &>/dev/null; then
        # macOS with GNU coreutils
        gdate -d "${ts} UTC - 1 second" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
    elif date --version 2>&1 | grep -q GNU; then
        # GNU date (Linux)
        date -d "${ts} UTC - 1 second" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
    else
        # BSD date (macOS default) - convert to epoch, subtract, convert back
        local epoch
        epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$ts" "+%s" 2>/dev/null) || epoch=""
        if [ -n "$epoch" ]; then
            epoch=$((epoch - 1))
            date -j -f "%s" "$epoch" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$ts"
        else
            echo "$ts"
        fi
    fi
}

# Scan a single pod's binlogs for the operation
# Returns via stdout: "FOUND|timestamp" or "NOT_FOUND" or "QUIT" or "ERROR"
# Progress messages go to stderr so they display when stdout is captured
scan_pod_binlogs() {
    local ns="$1"
    local pod="$2"
    local operation="$3"
    local table="$4"
    local database="$5"
    local interactive="$6"
    local password="$7"
    
    log_info "Scanning binlogs on pod: $pod"
    
    # Get binlog directory
    local binlog_dir
    binlog_dir=$(get_binlog_dir "$ns" "$pod" "$password")
    if [ -z "$binlog_dir" ]; then
        log_warn "  Could not determine binlog directory on $pod"
        echo "ERROR"
        return
    fi
    log_info "  Binlog directory: $binlog_dir"
    
    # Get list of binlogs
    local binlog_list
    binlog_list=$(get_binlog_list "$ns" "$pod" "$password")
    
    if [ -z "$binlog_list" ]; then
        log_warn "  No binlogs found on $pod. Binary logging may not be enabled."
        echo "NOT_FOUND"
        return
    fi
    
    # Convert to array
    local binlogs
    mapfile -t binlogs <<< "$binlog_list"
    local binlog_count=${#binlogs[@]}
    log_info "  Found $binlog_count binlog file(s)"
    
    # Iterate through binlogs from newest to oldest
    for ((i = binlog_count - 1; i >= 0; i--)); do
        local binlog="${binlogs[$i]}"
        
        echo_err ""
        log_info "  Examining binlog: $binlog ($((binlog_count - i)) of $binlog_count from newest)"
        
        # Get timestamp range
        local timestamps
        timestamps=$(get_binlog_timestamps "$ns" "$pod" "$binlog" "$binlog_dir")
        local first_ts="${timestamps%%|*}"
        local last_ts="${timestamps##*|}"
        
        if [ -z "$first_ts" ] || [ -z "$last_ts" ]; then
            log_warn "    Could not read timestamps from this binlog, skipping..."
            continue
        fi
        
        echo_err ""
        echo_err "    Binlog time range:"
        echo_err "      ${CYAN}Earliest:${NC} $first_ts"
        echo_err "      ${CYAN}Latest:${NC}   $last_ts"
        echo_err ""
        
        local should_search="y"
        if [ "$interactive" = "true" ]; then
            read -p "    Was the $operation on '$table' between these times? [y/n/q]: " confirm </dev/tty
            case "$confirm" in
                [Yy]*) should_search="y" ;;
                [Qq]*) echo "QUIT"; return ;;
                *) should_search="n" ;;
            esac
        fi
        
        if [ "$should_search" = "y" ]; then
            log_info "    Searching for $operation operation on '$table'..."
            
            local result
            result=$(search_binlog_for_operation "$ns" "$pod" "$binlog" "$binlog_dir" "$operation" "$table" "$database")
            
            if [ "$result" = "NOT_FOUND" ]; then
                log_warn "    Operation NOT FOUND in this binlog."
                if [ "$interactive" = "true" ]; then
                    read -p "    Try previous binlog? [y/n]: " try_prev </dev/tty
                    if [[ ! "$try_prev" =~ ^[Yy]$ ]]; then
                        echo "NOT_FOUND"
                        return
                    fi
                fi
                continue
            elif [ "$result" = "ERROR" ]; then
                log_error "    Error reading binlog"
                continue
            else
                # Found something! Parse the result (format: timestamp|||matched_statement)
                local found_ts="${result%%|||*}"
                local matched_stmt="${result##*|||}"
                
                echo_err ""
                log_success "    Found a potential match!"
                echo_err ""
                echo_err "      ${CYAN}Timestamp:${NC} $found_ts"
                echo_err "      ${CYAN}Statement:${NC}"
                echo_err "      ${YELLOW}$matched_stmt${NC}"
                echo_err ""
                
                # Ask user to confirm this is the correct statement
                local confirm_match="y"
                if [ "$interactive" = "true" ]; then
                    read -p "    Is this the correct destructive statement? [y/n]: " confirm_match </dev/tty
                fi
                
                if [[ "$confirm_match" =~ ^[Yy]$ ]]; then
                    local safe_ts
                    safe_ts=$(subtract_one_second "$found_ts")
                    echo "FOUND|$safe_ts|$matched_stmt"
                    return
                else
                    log_info "    Continuing to search for other matches..."
                    # Continue searching - need to modify the search to skip this match
                    # For now, just continue to next binlog
                    continue
                fi
            fi
        else
            log_info "    Skipping to previous binlog..."
            continue
        fi
    done
    
    # Exhausted all binlogs on this pod
    log_warn "  Searched all binlogs on $pod - operation not found."
    echo "NOT_FOUND"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -p|--pod)
            POD_NAME="$2"
            shift 2
            ;;
        -a|--all-pods)
            SCAN_ALL_PODS=true
            shift
            ;;
        -o|--operation)
            OPERATION="$2"
            shift 2
            ;;
        -d|--database)
            DATABASE_NAME="$2"
            shift 2
            ;;
        -t|--table)
            TABLE_NAME="$2"
            shift 2
            ;;
        --kubeconfig)
            KUBECONFIG="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            echo ""
            usage
            ;;
    esac
done

# Validate namespace
if [ -z "$NAMESPACE" ]; then
    log_error "Namespace is required. Use -n or --namespace."
    echo ""
    usage
fi

log_header "PITR Timestamp Finder"

log_info "This script helps find the timestamp just before a destructive operation"
log_info "for use with pxc-restore point-in-time recovery."
echo ""
log_warn "This is a READ-ONLY operation - no data will be modified."
echo ""

# Get all PXC pods
ALL_PODS=$(get_pxc_pods "$NAMESPACE")
if [ -z "$ALL_PODS" ]; then
    log_error "No running PXC pods found in namespace: $NAMESPACE"
    exit 1
fi

# Convert to array
read -ra POD_ARRAY <<< "$ALL_PODS"
POD_COUNT=${#POD_ARRAY[@]}

log_info "Found $POD_COUNT PXC pod(s) in namespace $NAMESPACE:"
for p in "${POD_ARRAY[@]}"; do
    echo "    - $p"
done
echo ""

# Handle pod selection
if [ "$SCAN_ALL_PODS" = true ]; then
    log_info "Will scan ALL pods (--all-pods specified)"
elif [ -n "$POD_NAME" ]; then
    # Validate provided pod exists in our list
    pod_found=false
    for p in "${POD_ARRAY[@]}"; do
        if [ "$p" = "$POD_NAME" ]; then
            pod_found=true
            break
        fi
    done
    if [ "$pod_found" = false ]; then
        log_error "Specified pod '$POD_NAME' not found in PXC cluster."
        log_info "Available pods: ${POD_ARRAY[*]}"
        exit 1
    fi
    log_success "Using specified pod: $POD_NAME"
else
    # Prompt user to select pod or scan all
    if [ "$POD_COUNT" -gt 1 ]; then
        echo ""
        log_warn "IMPORTANT: In a PXC cluster, binlogs are local to each pod."
        log_warn "If the primary (writer) changed, the destructive operation may be"
        log_warn "in a DIFFERENT pod's binlogs than the current primary."
        echo ""
        echo "Select which pod(s) to scan:"
        echo "  [0] Scan ALL pods (recommended if unsure)"
        for i in "${!POD_ARRAY[@]}"; do
            echo "  [$((i+1))] ${POD_ARRAY[$i]}"
        done
        echo ""
        read -p "Enter selection [0-$POD_COUNT]: " pod_choice
        
        if [ "$pod_choice" = "0" ]; then
            SCAN_ALL_PODS=true
            log_info "Will scan all pods."
        elif [[ "$pod_choice" =~ ^[0-9]+$ ]] && [ "$pod_choice" -ge 1 ] && [ "$pod_choice" -le "$POD_COUNT" ]; then
            POD_NAME="${POD_ARRAY[$((pod_choice-1))]}"
            log_success "Selected pod: $POD_NAME"
        else
            log_error "Invalid selection"
            exit 1
        fi
    else
        POD_NAME="${POD_ARRAY[0]}"
        log_success "Using pod: $POD_NAME"
    fi
fi

# Get destructive operation type if not provided
if [ -z "$OPERATION" ]; then
    echo ""
    echo "Select the destructive operation to search for:"
    echo "  [1] DROP TABLE"
    echo "  [2] DELETE FROM"
    echo "  [3] TRUNCATE TABLE"
    echo ""
    read -p "Enter selection [1-3]: " op_choice
    
    case "$op_choice" in
        1) OPERATION="DROP" ;;
        2) OPERATION="DELETE" ;;
        3) OPERATION="TRUNCATE" ;;
        *)
            log_error "Invalid selection"
            exit 1
            ;;
    esac
fi

# Validate and normalize operation
OPERATION=$(echo "$OPERATION" | tr '[:lower:]' '[:upper:]')
case "$OPERATION" in
    DROP|DELETE|TRUNCATE) ;;
    *)
        log_error "Invalid operation: $OPERATION. Must be DROP, DELETE, or TRUNCATE."
        exit 1
        ;;
esac

log_success "Searching for: $OPERATION"

# Get database name if not provided (optional)
if [ -z "$DATABASE_NAME" ]; then
    echo ""
    read -p "Enter database name (optional, press Enter to skip): " DATABASE_NAME
    if [ -n "$DATABASE_NAME" ]; then
        log_info "Filtering by database: $DATABASE_NAME"
    fi
fi

# Get table name if not provided
if [ -z "$TABLE_NAME" ]; then
    echo ""
    read -p "Enter table name: " TABLE_NAME
    
    if [ -z "$TABLE_NAME" ]; then
        log_error "Table name is required"
        exit 1
    fi
fi

log_success "Searching for table: $TABLE_NAME"

# Interactive mode - always interactive unless we add a --non-interactive flag later
INTERACTIVE="true"

# Get cluster name and MySQL root password
log_info "Getting cluster credentials..."
CLUSTER_NAME=$(get_cluster_name "$NAMESPACE")
if [ -z "$CLUSTER_NAME" ]; then
    log_error "Could not find PXC cluster in namespace: $NAMESPACE"
    exit 1
fi
log_success "Found cluster: $CLUSTER_NAME"

MYSQL_ROOT_PASSWORD=$(get_mysql_root_password "$NAMESPACE" "$CLUSTER_NAME")
if [ -z "$MYSQL_ROOT_PASSWORD" ]; then
    log_error "Could not get MySQL root password from cluster secrets"
    log_info "Checked secrets: ${CLUSTER_NAME}-secrets, internal-${CLUSTER_NAME}, ${CLUSTER_NAME}-pxc-secrets"
    exit 1
fi
log_success "Retrieved MySQL credentials"

echo ""
log_header "Scanning Binlogs"

FOUND_TIMESTAMP=""
FOUND_STATEMENT=""
FOUND_POD=""

if [ "$SCAN_ALL_PODS" = true ]; then
    # Scan all pods
    for pod in "${POD_ARRAY[@]}"; do
        echo ""
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        result=$(scan_pod_binlogs "$NAMESPACE" "$pod" "$OPERATION" "$TABLE_NAME" "$DATABASE_NAME" "$INTERACTIVE" "$MYSQL_ROOT_PASSWORD")
        
        if [[ "$result" == FOUND* ]]; then
            # Parse: FOUND|timestamp|statement
            local rest="${result#FOUND|}"
            FOUND_TIMESTAMP="${rest%%|*}"
            FOUND_STATEMENT="${rest#*|}"
            FOUND_POD="$pod"
            break
        elif [ "$result" = "QUIT" ]; then
            log_info "Exiting at user request."
            exit 0
        fi
        # Continue to next pod if NOT_FOUND or ERROR
    done
else
    # Scan single pod
    result=$(scan_pod_binlogs "$NAMESPACE" "$POD_NAME" "$OPERATION" "$TABLE_NAME" "$DATABASE_NAME" "$INTERACTIVE" "$MYSQL_ROOT_PASSWORD")
    
    if [[ "$result" == FOUND* ]]; then
        # Parse: FOUND|timestamp|statement
        local rest="${result#FOUND|}"
        FOUND_TIMESTAMP="${rest%%|*}"
        FOUND_STATEMENT="${rest#*|}"
        FOUND_POD="$POD_NAME"
    elif [ "$result" = "QUIT" ]; then
        log_info "Exiting at user request."
        exit 0
    fi
fi

echo ""

if [ -z "$FOUND_TIMESTAMP" ]; then
    log_header "Search Complete - NOT FOUND"
    
    log_error "Could not find '$OPERATION ... $TABLE_NAME' in any scanned binlog."
    echo ""
    log_info "Possible reasons:"
    log_info "  1. The table name does not match exactly (check spelling, case)"
    if [ -n "$DATABASE_NAME" ]; then
        log_info "  2. The database name '$DATABASE_NAME' does not match exactly"
    else
        log_info "  2. Try specifying the database name with -d to narrow the search"
    fi
    log_info "  3. The operation occurred before the oldest available binlog"
    log_info "  4. Binary logging was not enabled at the time of the operation"
    if [ "$SCAN_ALL_PODS" = false ] && [ "$POD_COUNT" -gt 1 ]; then
        log_info "  5. The operation may be in a different pod's binlogs (try --all-pods)"
    fi
    echo ""
    log_info "Tips:"
    log_info "  - Table names are case-sensitive in the binlog"
    log_info "  - Try searching without the database name first"
    log_info "  - Check if the table ever existed: SHOW TABLES LIKE '%$TABLE_NAME%'"
    exit 1
fi

log_header "Result"

echo -e "  ${GREEN}${BOLD}Found timestamp for PITR restore:${NC}"
echo ""
echo -e "  ${CYAN}${BOLD}$FOUND_TIMESTAMP${NC}"
echo ""
echo "  Found on pod: $FOUND_POD"
echo ""
echo -e "  ${CYAN}Matched statement:${NC}"
echo -e "  ${YELLOW}$FOUND_STATEMENT${NC}"
echo ""
echo "  This timestamp represents the moment just BEFORE the above operation."
echo "  Use this timestamp with pxc-restore for point-in-time recovery:"
echo ""
echo -e "  ${YELLOW}pxc-restore -n $NAMESPACE -t <target-namespace> -r \"$FOUND_TIMESTAMP\"${NC}"
echo ""
log_success "Done."
