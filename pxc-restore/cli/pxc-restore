#!/bin/bash
#
# PXC Point-in-Time Restore CLI
# A command-line interface for restoring Percona XtraDB Cluster to any point in time.
# This CLI uses the REST API backend for all operations.
#

set -euo pipefail

# Configuration
API_BASE="${PXC_RESTORE_API:-http://localhost:8081}"
VERBOSE=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_header() {
    echo ""
    echo -e "${CYAN}=====================================================${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}=====================================================${NC}"
    echo ""
}

# Usage
usage() {
    cat << EOF
PXC Point-in-Time Restore CLI

Usage: $0 [OPTIONS]

OPTIONS:
    -n, --namespace NAMESPACE   Source namespace containing the PXC cluster to restore from
    -a, --api-url URL           API server URL (default: http://localhost:8081)
    -v, --verbose               Enable verbose output
    -h, --help                  Show this help message

ENVIRONMENT VARIABLES:
    PXC_RESTORE_API             API server URL (overridden by --api-url)

EXAMPLES:
    # Interactive restore (recommended)
    $0 -n percona

    # Using a different API server
    $0 -n percona -a http://pxc-restore.example.com:8081

    # Verbose mode
    $0 -n percona -v

WORKFLOW:
    1. Lists all available backups in the source namespace
    2. Shows earliest and latest restorable times
    3. Prompts for backup selection and restore time
    4. Prompts for target namespace (creates if needed)
    5. Creates a new PXC cluster and restores to specified time
    6. Displays restore summary with databases and table counts

NOTE: The source cluster and namespace are NEVER modified.
EOF
    exit 0
}

# API helpers
api_get() {
    local endpoint="$1"
    local response
    response=$(curl -s -f "${API_BASE}${endpoint}" 2>/dev/null) || {
        log_error "API request failed: GET ${endpoint}"
        log_error "Is the API server running at ${API_BASE}?"
        exit 1
    }
    echo "$response"
}

api_post() {
    local endpoint="$1"
    local data="$2"
    local response
    response=$(curl -s -f -X POST -H "Content-Type: application/json" -d "$data" "${API_BASE}${endpoint}" 2>/dev/null) || {
        log_error "API request failed: POST ${endpoint}"
        exit 1
    }
    echo "$response"
}

# Parse arguments
SOURCE_NAMESPACE=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            SOURCE_NAMESPACE="$2"
            shift 2
            ;;
        -a|--api-url)
            API_BASE="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Validate arguments
if [ -z "$SOURCE_NAMESPACE" ]; then
    log_error "Source namespace is required. Use -n or --namespace."
    echo ""
    usage
fi

# Check dependencies
if ! command -v curl &> /dev/null; then
    log_error "curl is required but not installed"
    exit 1
fi

if ! command -v jq &> /dev/null; then
    log_error "jq is required but not installed"
    exit 1
fi

# Check API connectivity
log_info "Connecting to API server at ${API_BASE}..."
if ! curl -s -f "${API_BASE}/api/backups?namespace=test" &>/dev/null; then
    # Try anyway - the namespace test may fail but server should respond
    if ! curl -s --connect-timeout 5 "${API_BASE}/" &>/dev/null; then
        log_error "Cannot connect to API server at ${API_BASE}"
        log_error "Start the server with: cd pxc-restore && ./start.sh"
        exit 1
    fi
fi
log_success "Connected to API server"

# Main workflow
log_header "PXC Point-in-Time Restore"

# Step 1: Load backups
log_info "Loading backups from namespace: ${SOURCE_NAMESPACE}"
BACKUPS_RESPONSE=$(api_get "/api/backups?namespace=${SOURCE_NAMESPACE}")

# Check for errors
if echo "$BACKUPS_RESPONSE" | jq -e '.backups | length == 0' &>/dev/null; then
    MESSAGE=$(echo "$BACKUPS_RESPONSE" | jq -r '.message // "No backups found"')
    log_error "$MESSAGE"
    exit 1
fi

CLUSTER_NAME=$(echo "$BACKUPS_RESPONSE" | jq -r '.clusterName')
EARLIEST_TIME=$(echo "$BACKUPS_RESPONSE" | jq -r '.earliestRestorableTime // "N/A"')
LATEST_TIME=$(echo "$BACKUPS_RESPONSE" | jq -r '.latestRestorableTime // "N/A"')
BACKUP_COUNT=$(echo "$BACKUPS_RESPONSE" | jq -r '.backups | length')

log_success "Found ${BACKUP_COUNT} backup(s) for cluster: ${CLUSTER_NAME}"

# Display backups
log_header "Available Backups"
echo ""
printf "%-4s %-40s %-12s %-10s %-25s\n" "#" "BACKUP NAME" "STATE" "PITR" "LATEST RESTORABLE"
printf "%s\n" "--------------------------------------------------------------------------------"

BACKUP_NAMES=()
i=1
while IFS= read -r backup; do
    name=$(echo "$backup" | jq -r '.name')
    state=$(echo "$backup" | jq -r '.state')
    pitr=$(echo "$backup" | jq -r 'if .pitrReady then "Yes" else "No" end')
    latest=$(echo "$backup" | jq -r '.latestRestorableTime // "N/A"' | cut -c1-25)
    
    BACKUP_NAMES+=("$name")
    printf "%-4s %-40s %-12s %-10s %-25s\n" "[$i]" "$name" "$state" "$pitr" "$latest"
    ((i++))
done < <(echo "$BACKUPS_RESPONSE" | jq -c '.backups[]')
echo ""

# Display time range
log_header "Restorable Time Window"
echo ""
echo -e "  ${CYAN}Earliest:${NC} ${EARLIEST_TIME} UTC"
echo -e "  ${CYAN}Latest:${NC}   ${LATEST_TIME} UTC"
echo ""
echo "  You can restore to any point in time between these values."
echo "  Format: YYYY-MM-DD HH:MM:SS (e.g., 2025-01-15 14:30:00)"
echo ""

# Step 2: Select backup
echo -n "Select backup number [1]: "
read -r BACKUP_NUM
BACKUP_NUM=${BACKUP_NUM:-1}

if ! [[ "$BACKUP_NUM" =~ ^[0-9]+$ ]] || [ "$BACKUP_NUM" -lt 1 ] || [ "$BACKUP_NUM" -gt "$BACKUP_COUNT" ]; then
    log_error "Invalid backup selection"
    exit 1
fi

SELECTED_BACKUP="${BACKUP_NAMES[$((BACKUP_NUM-1))]}"
log_success "Selected backup: ${SELECTED_BACKUP}"

# Get backup details for time range
BACKUP_DETAILS=$(echo "$BACKUPS_RESPONSE" | jq -r ".backups[$((BACKUP_NUM-1))]")
BACKUP_COMPLETED=$(echo "$BACKUP_DETAILS" | jq -r '.completed // ""')
BACKUP_LATEST=$(echo "$BACKUP_DETAILS" | jq -r '.latestRestorableTime // ""')

if [ -n "$BACKUP_COMPLETED" ]; then
    BACKUP_EARLIEST_FORMATTED=$(echo "$BACKUP_COMPLETED" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
    echo ""
    echo "  This backup allows restore from: ${BACKUP_EARLIEST_FORMATTED} UTC"
fi
if [ -n "$BACKUP_LATEST" ]; then
    BACKUP_LATEST_FORMATTED=$(echo "$BACKUP_LATEST" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
    echo "  To: ${BACKUP_LATEST_FORMATTED} UTC"
fi

# Step 3: Enter restore time
echo ""
echo -n "Enter restore time (YYYY-MM-DD HH:MM:SS) [${BACKUP_LATEST_FORMATTED:-now}]: "
read -r RESTORE_TIME
RESTORE_TIME=${RESTORE_TIME:-${BACKUP_LATEST_FORMATTED:-$(date -u '+%Y-%m-%d %H:%M:%S')}}

# Validate time format
if ! [[ "$RESTORE_TIME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
    log_error "Invalid time format. Use: YYYY-MM-DD HH:MM:SS"
    exit 1
fi
log_success "Restore time: ${RESTORE_TIME} UTC"

# Step 4: Target namespace
log_header "Target Namespace"
echo ""
echo "The restore will create a NEW cluster in a target namespace."
echo "The source namespace (${SOURCE_NAMESPACE}) will NOT be modified."
echo ""

while true; do
    echo -n "Enter target namespace: "
    read -r TARGET_NAMESPACE
    
    if [ -z "$TARGET_NAMESPACE" ]; then
        log_warn "Target namespace cannot be empty"
        continue
    fi
    
    if [ "$TARGET_NAMESPACE" = "$SOURCE_NAMESPACE" ]; then
        log_warn "Cannot restore to the source namespace"
        continue
    fi
    
    # Validate namespace name
    if ! [[ "$TARGET_NAMESPACE" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
        log_warn "Invalid namespace name. Use lowercase letters, numbers, and hyphens."
        continue
    fi
    
    # Check namespace
    log_info "Checking namespace: ${TARGET_NAMESPACE}"
    NS_RESPONSE=$(api_get "/api/namespace/check?namespace=${TARGET_NAMESPACE}")
    NS_EXISTS=$(echo "$NS_RESPONSE" | jq -r '.exists')
    NS_HAS_PXC=$(echo "$NS_RESPONSE" | jq -r '.hasPxc')
    NS_MESSAGE=$(echo "$NS_RESPONSE" | jq -r '.message')
    
    if [ "$NS_EXISTS" = "true" ]; then
        if [ "$NS_HAS_PXC" = "true" ]; then
            log_warn "$NS_MESSAGE"
            echo -n "Continue anyway? [y/N]: "
            read -r CONTINUE
            if [[ ! "$CONTINUE" =~ ^[Yy]$ ]]; then
                continue
            fi
        else
            log_success "Namespace exists and is ready"
        fi
        break
    else
        echo ""
        echo -n "Namespace does not exist. Create it? [Y/n]: "
        read -r CREATE_NS
        if [[ ! "$CREATE_NS" =~ ^[Nn]$ ]]; then
            log_info "Creating namespace: ${TARGET_NAMESPACE}"
            CREATE_RESPONSE=$(api_post "/api/namespace/create" "{\"namespace\":\"${TARGET_NAMESPACE}\"}")
            if echo "$CREATE_RESPONSE" | jq -e '.success' &>/dev/null; then
                log_success "Namespace created successfully"
                break
            else
                MSG=$(echo "$CREATE_RESPONSE" | jq -r '.message // "Failed to create namespace"')
                log_error "$MSG"
                continue
            fi
        fi
    fi
done

# Step 5: Confirmation
log_header "Restore Summary"
echo ""
echo -e "  ${CYAN}Source Namespace:${NC}  ${SOURCE_NAMESPACE}"
echo -e "  ${CYAN}Source Cluster:${NC}    ${CLUSTER_NAME}"
echo -e "  ${CYAN}Backup:${NC}            ${SELECTED_BACKUP}"
echo -e "  ${CYAN}Restore To:${NC}        ${RESTORE_TIME} UTC"
echo -e "  ${CYAN}Target Namespace:${NC}  ${TARGET_NAMESPACE}"
echo -e "  ${CYAN}New Cluster Name:${NC}  ${CLUSTER_NAME}-restored"
echo ""
echo -e "${YELLOW}WARNING: This will create a new PXC cluster in the target namespace.${NC}"
echo -e "${YELLOW}         The source cluster and namespace will NOT be modified.${NC}"
echo ""
echo -n "Proceed with restore? [y/N]: "
read -r CONFIRM
if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
    log_info "Restore cancelled"
    exit 0
fi

# Step 6: Execute restore
log_header "Starting Restore"

RESTORE_PAYLOAD=$(cat <<EOF
{
    "sourceNamespace": "${SOURCE_NAMESPACE}",
    "targetNamespace": "${TARGET_NAMESPACE}",
    "backupName": "${SELECTED_BACKUP}",
    "restoreTime": "${RESTORE_TIME}",
    "createNamespace": false
}
EOF
)

log_info "Initiating restore..."
RESTORE_RESPONSE=$(api_post "/api/restore" "$RESTORE_PAYLOAD")

if ! echo "$RESTORE_RESPONSE" | jq -e '.success' &>/dev/null; then
    MSG=$(echo "$RESTORE_RESPONSE" | jq -r '.message // "Restore failed"')
    log_error "$MSG"
    exit 1
fi

RESTORE_NAME=$(echo "$RESTORE_RESPONSE" | jq -r '.restoreName')
NEW_CLUSTER_NAME=$(echo "$RESTORE_RESPONSE" | jq -r '.clusterName')

log_success "Restore initiated: ${RESTORE_NAME}"
log_info "Waiting for restore to complete..."
echo ""

# Poll for status
MAX_ATTEMPTS=120
ATTEMPT=0
LAST_STATE=""

while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
    ((ATTEMPT++))
    
    # Get restore status
    STATUS_RESPONSE=$(api_get "/api/restore/status?namespace=${TARGET_NAMESPACE}&name=${RESTORE_NAME}" 2>/dev/null || echo '{"state":"Pending"}')
    RESTORE_STATE=$(echo "$STATUS_RESPONSE" | jq -r '.state // "Pending"')
    
    # Get cluster status
    CLUSTER_RESPONSE=$(api_get "/api/cluster/status?namespace=${TARGET_NAMESPACE}&cluster=${NEW_CLUSTER_NAME}" 2>/dev/null || echo '{"state":"initializing"}')
    CLUSTER_STATE=$(echo "$CLUSTER_RESPONSE" | jq -r '.state // "initializing"')
    PXC_READY=$(echo "$CLUSTER_RESPONSE" | jq -r '.pxcReady // "0"')
    PXC_SIZE=$(echo "$CLUSTER_RESPONSE" | jq -r '.pxcSize // "?"')
    
    # Update display
    if [ "$VERBOSE" = true ] || [ "$RESTORE_STATE" != "$LAST_STATE" ]; then
        printf "\r  Restore: %-15s | Cluster: %-15s | Nodes: %s/%s" "$RESTORE_STATE" "$CLUSTER_STATE" "$PXC_READY" "$PXC_SIZE"
        LAST_STATE="$RESTORE_STATE"
    fi
    
    # Check if complete
    if [ "$RESTORE_STATE" = "Succeeded" ] || [ "$RESTORE_STATE" = "Ready" ]; then
        if [ "$CLUSTER_STATE" = "ready" ]; then
            echo ""
            log_success "Restore completed successfully!"
            break
        fi
    elif [ "$RESTORE_STATE" = "Failed" ] || [ "$RESTORE_STATE" = "Error" ]; then
        echo ""
        MSG=$(echo "$STATUS_RESPONSE" | jq -r '.message // "Unknown error"')
        log_error "Restore failed: $MSG"
        exit 1
    fi
    
    sleep 5
done

if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
    echo ""
    log_error "Restore timed out after 10 minutes"
    log_info "Check status manually: kubectl get pxc-restore ${RESTORE_NAME} -n ${TARGET_NAMESPACE}"
    exit 1
fi

# Step 7: Summary
log_header "Restore Complete"

log_info "Fetching database summary..."
SUMMARY_RESPONSE=$(api_get "/api/restore/summary?namespace=${TARGET_NAMESPACE}&cluster=${NEW_CLUSTER_NAME}" 2>/dev/null || echo '{}')

echo ""
echo -e "  ${CYAN}Restored Cluster:${NC}  ${NEW_CLUSTER_NAME}"
echo -e "  ${CYAN}Namespace:${NC}         ${TARGET_NAMESPACE}"
echo -e "  ${CYAN}Restore Time:${NC}      ${RESTORE_TIME} UTC"
echo ""

# Display databases
DBS=$(echo "$SUMMARY_RESPONSE" | jq -r '.databases // []')
if [ "$(echo "$DBS" | jq 'length')" -gt 0 ]; then
    echo "  Databases:"
    printf "  %-30s %s\n" "DATABASE" "TABLES"
    printf "  %s\n" "----------------------------------------"
    echo "$DBS" | jq -r '.[] | "  \(.name)\t\(.tableCount)"' | while read -r line; do
        db=$(echo "$line" | cut -f1)
        count=$(echo "$line" | cut -f2)
        printf "  %-30s %s\n" "$db" "$count"
    done
    TOTAL=$(echo "$SUMMARY_RESPONSE" | jq -r '.totalTables // 0')
    printf "  %s\n" "----------------------------------------"
    printf "  %-30s %s\n" "TOTAL" "$TOTAL"
else
    echo "  No user databases found (only system databases exist)."
fi

echo ""
echo "  Connect to the restored cluster:"
echo -e "  ${CYAN}kubectl exec -it ${NEW_CLUSTER_NAME}-pxc-0 -n ${TARGET_NAMESPACE} -c pxc -- mysql -uroot -p${NC}"
echo ""
log_success "Restore completed successfully!"
