#!/bin/bash
#
# PXC Point-in-Time Restore CLI
# Standalone CLI for restoring Percona XtraDB Cluster to any point in time.
# Uses kubectl directly - no API server required.
#

set -euo pipefail

# Configuration
KUBECONFIG="${KUBECONFIG:-}"
VERBOSE=false
DRY_RUN=false
SOURCE_NAMESPACE=""
TARGET_NAMESPACE=""
BACKUP_NAME=""
RESTORE_TIME=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_dry() { echo -e "${CYAN}[DRY-RUN]${NC} $1"; }
log_header() {
    echo ""
    echo -e "${CYAN}=====================================================${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}=====================================================${NC}"
    echo ""
}

# kubectl wrapper
kctl() {
    if [ -n "$KUBECONFIG" ]; then
        kubectl --kubeconfig="$KUBECONFIG" "$@"
    else
        kubectl "$@"
    fi
}

# Usage
usage() {
    cat << EOF
PXC Point-in-Time Restore CLI

Restore Percona XtraDB Cluster to any point in time using PITR backups.
This tool creates a NEW cluster in a target namespace - the source is NEVER modified.

USAGE:
    $0 -n NAMESPACE [OPTIONS]

REQUIRED:
    -n, --namespace NAMESPACE   Source namespace containing the PXC cluster to restore from

OPTIONS:
    -t, --target NAMESPACE      Target namespace (will prompt if not provided)
    -b, --backup NAME           Backup name (will prompt if not provided)
    -r, --restore-time TIME     Restore time in "YYYY-MM-DD HH:MM:SS" UTC format
    --dry-run                   Show what would be done without making changes
    --kubeconfig PATH           Path to kubeconfig file
    -v, --verbose               Enable verbose output
    -h, --help                  Show this help message

EXAMPLES:
    # Interactive restore
    $0 -n percona

    # Dry run to verify prerequisites
    $0 -n percona --dry-run

    # Non-interactive with all options
    $0 -n percona -t percona-restored -b daily-backup-20250115 -r "2025-01-15 14:30:00"

    # Dry run with specific options
    $0 -n percona -t test-restore -b daily-backup --dry-run

TIME FORMAT:
    YYYY-MM-DD HH:MM:SS (UTC)
    Example: 2025-01-15 14:30:00

WORKFLOW:
    1. Lists all available backups in the source namespace
    2. Shows earliest and latest restorable times based on PITR
    3. Prompts for backup selection and restore time
    4. Prompts for target namespace (creates if needed)
    5. Creates a new PXC cluster and restores to specified time
    6. Displays restore summary with databases and table counts

NOTE: The source cluster and namespace are NEVER modified.
EOF
    exit 0
}

# Check prerequisites
check_prerequisites() {
    local errors=0
    local warnings=0

    log_header "Checking Prerequisites"

    # Check kubectl
    if command -v kubectl &> /dev/null; then
        local kversion
        kversion=$(kubectl version --client -o json 2>/dev/null | jq -r '.clientVersion.gitVersion' 2>/dev/null || echo "unknown")
        log_success "kubectl installed: $kversion"
    else
        log_error "kubectl is not installed or not in PATH"
        ((errors++))
    fi

    # Check jq
    if command -v jq &> /dev/null; then
        log_success "jq installed: $(jq --version)"
    else
        log_error "jq is not installed (required for JSON parsing)"
        ((errors++))
    fi

    # Check base64
    if command -v base64 &> /dev/null; then
        log_success "base64 installed"
    else
        log_error "base64 is not installed (required for secret decoding)"
        ((errors++))
    fi

    # Check cluster connectivity
    if kctl cluster-info &>/dev/null; then
        local context
        context=$(kctl config current-context 2>/dev/null || echo "unknown")
        log_success "Kubernetes cluster accessible (context: $context)"
    else
        log_error "Cannot connect to Kubernetes cluster"
        log_error "Ensure KUBECONFIG is set or kubectl is configured"
        ((errors++))
        # Can't continue without cluster access
        echo ""
        log_error "$errors prerequisite check(s) failed"
        return 1
    fi

    # Check source namespace exists
    if [ -n "$SOURCE_NAMESPACE" ]; then
        if kctl get namespace "$SOURCE_NAMESPACE" &>/dev/null; then
            log_success "Source namespace exists: $SOURCE_NAMESPACE"
        else
            log_error "Source namespace does not exist: $SOURCE_NAMESPACE"
            ((errors++))
        fi
    fi

    # Check PXC operator CRDs are installed
    if kctl get crd perconaxtradbclusters.pxc.percona.com &>/dev/null; then
        log_success "Percona XtraDB Cluster operator CRDs installed"
    else
        log_error "Percona XtraDB Cluster operator CRDs not installed"
        ((errors++))
    fi

    # Check PXC operator is running
    local operator_ns=""
    local operator_running=false
    for ns in "percona" "pxc-operator" "default" "$SOURCE_NAMESPACE"; do
        if [ -n "$ns" ]; then
            local operator_pods
            operator_pods=$(kctl get pods -n "$ns" -l app.kubernetes.io/name=percona-xtradb-cluster-operator -o jsonpath='{.items[*].status.phase}' 2>/dev/null || echo "")
            if echo "$operator_pods" | grep -q "Running"; then
                operator_ns="$ns"
                operator_running=true
                break
            fi
        fi
    done
    if [ "$operator_running" = true ]; then
        log_success "PXC operator is running (namespace: $operator_ns)"
    else
        log_warn "Could not verify PXC operator is running (may be in a different namespace)"
        ((warnings++))
    fi

    # Check for PXC cluster in source namespace
    local cluster_name=""
    if [ -n "$SOURCE_NAMESPACE" ]; then
        cluster_name=$(kctl get perconaxtradbcluster -n "$SOURCE_NAMESPACE" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        if [ -n "$cluster_name" ]; then
            log_success "Found PXC cluster in source namespace: $cluster_name"
            
            # Check cluster is in ready state
            local cluster_state
            cluster_state=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.status.state}' 2>/dev/null || echo "")
            if [ "$cluster_state" = "ready" ]; then
                log_success "Source cluster is in ready state"
            else
                log_warn "Source cluster state is: ${cluster_state:-unknown} (expected: ready)"
                ((warnings++))
            fi
        else
            log_error "No PXC cluster found in namespace: $SOURCE_NAMESPACE"
            ((errors++))
        fi
    fi

    # Check for backups
    if [ -n "$SOURCE_NAMESPACE" ]; then
        local backup_count succeeded_count
        backup_count=$(kctl get perconaxtradbclusterbackup -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq '.items | length' 2>/dev/null || echo "0")
        succeeded_count=$(kctl get perconaxtradbclusterbackup -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq '[.items[] | select(.status.state == "Succeeded" or .status.state == "Ready")] | length' 2>/dev/null || echo "0")
        
        if [ "$backup_count" -gt 0 ]; then
            log_success "Found $backup_count backup(s) in source namespace ($succeeded_count succeeded)"
            if [ "$succeeded_count" -eq 0 ]; then
                log_error "No backups in Succeeded state"
                ((errors++))
            fi
        else
            log_error "No backups found in namespace: $SOURCE_NAMESPACE"
            ((errors++))
        fi
    fi

    # Check cluster secrets exist
    if [ -n "$cluster_name" ] && [ -n "$SOURCE_NAMESPACE" ]; then
        local secrets_name
        secrets_name=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.secretsName}' 2>/dev/null || echo "")
        if [ -z "$secrets_name" ]; then
            secrets_name="${cluster_name}-secrets"
        fi
        
        if kctl get secret "$secrets_name" -n "$SOURCE_NAMESPACE" &>/dev/null; then
            log_success "Cluster secrets exist: $secrets_name"
            
            # Verify root password key exists
            local root_key
            root_key=$(kctl get secret "$secrets_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.data.root}' 2>/dev/null || echo "")
            if [ -n "$root_key" ]; then
                log_success "Root password found in secrets"
            else
                log_warn "Root password key not found in secrets (may use different key name)"
                ((warnings++))
            fi
        else
            log_error "Cluster secrets not found: $secrets_name"
            ((errors++))
        fi
    fi

    # Check backup storage configuration and credentials
    if [ -n "$cluster_name" ] && [ -n "$SOURCE_NAMESPACE" ]; then
        local backup_storages
        backup_storages=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.backup.storages}' 2>/dev/null || echo "")
        
        if [ -n "$backup_storages" ] && [ "$backup_storages" != "{}" ]; then
            log_success "Backup storage configured in cluster spec"
            
            # Get credentials secret name
            local creds_secret
            creds_secret=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.backup.storages[]?.s3?.credentialsSecret // empty' | head -1)
            
            if [ -n "$creds_secret" ]; then
                if kctl get secret "$creds_secret" -n "$SOURCE_NAMESPACE" &>/dev/null; then
                    log_success "Backup credentials secret exists: $creds_secret"
                    
                    # Verify expected keys exist
                    local has_access has_secret
                    has_access=$(kctl get secret "$creds_secret" -n "$SOURCE_NAMESPACE" -o jsonpath='{.data.AWS_ACCESS_KEY_ID}' 2>/dev/null || echo "")
                    has_secret=$(kctl get secret "$creds_secret" -n "$SOURCE_NAMESPACE" -o jsonpath='{.data.AWS_SECRET_ACCESS_KEY}' 2>/dev/null || echo "")
                    
                    if [ -n "$has_access" ] && [ -n "$has_secret" ]; then
                        log_success "Backup credentials contain required keys"
                    else
                        log_warn "Backup credentials may be missing AWS_ACCESS_KEY_ID or AWS_SECRET_ACCESS_KEY"
                        ((warnings++))
                    fi
                else
                    log_error "Backup credentials secret not found: $creds_secret"
                    ((errors++))
                fi
            else
                log_warn "No backup credentials secret configured (may use IAM roles)"
                ((warnings++))
            fi
            
            # Check backup endpoint/bucket configuration
            local backup_bucket backup_endpoint
            backup_bucket=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.backup.storages[]?.s3?.bucket // empty' | head -1)
            backup_endpoint=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.backup.storages[]?.s3?.endpointUrl // empty' | head -1)
            
            if [ -n "$backup_bucket" ]; then
                log_success "Backup bucket configured: $backup_bucket"
            else
                log_warn "Backup bucket not found in storage configuration"
                ((warnings++))
            fi
            
            if [ -n "$backup_endpoint" ]; then
                log_success "Backup endpoint configured: $backup_endpoint"
            else
                log_info "No custom endpoint (using AWS S3)"
            fi
        else
            log_error "No backup storage configured in cluster spec"
            ((errors++))
        fi
    fi

    # Check PITR configuration
    if [ -n "$cluster_name" ] && [ -n "$SOURCE_NAMESPACE" ]; then
        local pitr_enabled
        pitr_enabled=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.backup.pitr.enabled}' 2>/dev/null || echo "")
        
        if [ "$pitr_enabled" = "true" ]; then
            log_success "PITR is enabled on source cluster"
        else
            log_warn "PITR may not be enabled (spec.backup.pitr.enabled != true)"
            log_warn "Point-in-time restore may fail or be limited to backup completion time"
            ((warnings++))
        fi
    fi

    # Check if we can create namespaces (RBAC check)
    if kctl auth can-i create namespaces &>/dev/null; then
        log_success "Permission to create namespaces: yes"
    else
        log_warn "Permission to create namespaces: no (will need existing namespace)"
        ((warnings++))
    fi

    # Check storage classes exist (for PVC creation)
    local storage_class
    if [ -n "$cluster_name" ] && [ -n "$SOURCE_NAMESPACE" ]; then
        storage_class=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.pxc.volumeSpec.persistentVolumeClaim.storageClassName}' 2>/dev/null || echo "")
        if [ -z "$storage_class" ]; then
            # Try alternate path
            storage_class=$(kctl get perconaxtradbcluster "$cluster_name" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.pxc.persistence.storageClass // empty')
        fi
    fi
    
    if [ -n "$storage_class" ]; then
        if kctl get storageclass "$storage_class" &>/dev/null; then
            log_success "Storage class exists: $storage_class"
        else
            log_error "Storage class not found: $storage_class"
            ((errors++))
        fi
    else
        # Check default storage class
        local default_sc
        default_sc=$(kctl get storageclass -o jsonpath='{.items[?(@.metadata.annotations.storageclass\.kubernetes\.io/is-default-class=="true")].metadata.name}' 2>/dev/null || echo "")
        if [ -n "$default_sc" ]; then
            log_success "Default storage class available: $default_sc"
        else
            log_warn "No default storage class found (cluster may use specific storage class)"
            ((warnings++))
        fi
    fi

    # Check available nodes
    local ready_nodes
    ready_nodes=$(kctl get nodes -o json 2>/dev/null | jq '[.items[] | select(.status.conditions[] | select(.type=="Ready" and .status=="True"))] | length' 2>/dev/null || echo "0")
    if [ "$ready_nodes" -gt 0 ]; then
        log_success "Ready nodes available: $ready_nodes"
    else
        log_error "No ready nodes found in cluster"
        ((errors++))
    fi

    echo ""
    if [ $errors -gt 0 ]; then
        log_error "$errors prerequisite check(s) failed"
        if [ $warnings -gt 0 ]; then
            log_warn "$warnings warning(s)"
        fi
        return 1
    else
        log_success "All prerequisite checks passed"
        if [ $warnings -gt 0 ]; then
            log_warn "$warnings warning(s) - review above for details"
        fi
        return 0
    fi
}

# Get cluster name from namespace
get_cluster_name() {
    local ns="$1"
    kctl get perconaxtradbcluster -n "$ns" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo ""
}

# List backups and return JSON
get_backups() {
    local ns="$1"
    kctl get perconaxtradbclusterbackup -n "$ns" -o json 2>/dev/null || echo '{"items":[]}'
}

# Display backups and let user select
display_and_select_backup() {
    local ns="$1"
    local backups_json
    backups_json=$(get_backups "$ns")

    local backup_count
    backup_count=$(echo "$backups_json" | jq '.items | length')

    if [ "$backup_count" -eq 0 ]; then
        log_error "No backups found in namespace: $ns"
        exit 1
    fi

    log_header "Available Backups"

    # Build arrays for selection
    local -a backup_names=()
    local -a backup_states=()
    local -a backup_completed=()
    local -a backup_latest=()
    local -a backup_pitr=()
    local -a backup_storage=()

    while IFS= read -r item; do
        local name state completed latest pitr storage
        name=$(echo "$item" | jq -r '.metadata.name')
        state=$(echo "$item" | jq -r '.status.state // "Unknown"')
        completed=$(echo "$item" | jq -r '.status.completed // ""')
        latest=$(echo "$item" | jq -r '.status.latestRestorableTime // ""')
        storage=$(echo "$item" | jq -r '.spec.storageName // ""')
        
        # Check PITRReady condition
        pitr=$(echo "$item" | jq -r '.status.conditions[]? | select(.type=="PITRReady") | .status' 2>/dev/null || echo "")
        if [ "$pitr" = "True" ]; then
            pitr="Yes"
        else
            pitr="No"
        fi

        # Only include succeeded backups
        if [ "$state" = "Succeeded" ] || [ "$state" = "Ready" ]; then
            backup_names+=("$name")
            backup_states+=("$state")
            backup_completed+=("$completed")
            backup_latest+=("$latest")
            backup_pitr+=("$pitr")
            backup_storage+=("$storage")
        fi
    done < <(echo "$backups_json" | jq -c '.items[]')

    local valid_count=${#backup_names[@]}
    if [ "$valid_count" -eq 0 ]; then
        log_error "No completed backups found in namespace: $ns"
        exit 1
    fi

    # Display table with backup completed time and latest restorable time
    printf "%-4s %-35s %-10s %-6s %-20s %-20s\n" "#" "BACKUP NAME" "STATE" "PITR" "COMPLETED (UTC)" "LATEST RESTORABLE"
    printf "%s\n" "--------------------------------------------------------------------------------------------------------------"

    for i in "${!backup_names[@]}"; do
        local idx=$((i + 1))
        local completed_display="${backup_completed[$i]}"
        local latest_display="${backup_latest[$i]}"
        
        if [ -n "$completed_display" ]; then
            completed_display=$(echo "$completed_display" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
        else
            completed_display="N/A"
        fi
        
        if [ -n "$latest_display" ]; then
            latest_display=$(echo "$latest_display" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
        else
            latest_display="N/A"
        fi
        printf "%-4s %-35s %-10s %-6s %-20s %-20s\n" "[$idx]" "${backup_names[$i]}" "${backup_states[$i]}" "${backup_pitr[$i]}" "$completed_display" "$latest_display"
    done
    echo ""

    # Select backup first
    local selected_idx
    if [ -n "$BACKUP_NAME" ]; then
        # Find index of specified backup
        for i in "${!backup_names[@]}"; do
            if [ "${backup_names[$i]}" = "$BACKUP_NAME" ]; then
                selected_idx=$i
                break
            fi
        done
        if [ -z "$selected_idx" ]; then
            log_error "Specified backup not found: $BACKUP_NAME"
            exit 1
        fi
        log_info "Using specified backup: $BACKUP_NAME"
    else
        echo -n "Select backup number [1]: "
        read -r backup_num
        backup_num=${backup_num:-1}

        if ! [[ "$backup_num" =~ ^[0-9]+$ ]] || [ "$backup_num" -lt 1 ] || [ "$backup_num" -gt "$valid_count" ]; then
            log_error "Invalid backup selection"
            exit 1
        fi
        selected_idx=$((backup_num - 1))
    fi

    BACKUP_NAME="${backup_names[$selected_idx]}"
    log_success "Selected backup: ${BACKUP_NAME}"

    # Export for later use
    BACKUP_COMPLETED="${backup_completed[$selected_idx]}"
    BACKUP_LATEST="${backup_latest[$selected_idx]}"
    BACKUP_STORAGE="${backup_storage[$selected_idx]}"

    # Now show the restorable time window for this specific backup
    log_header "Restorable Time Window for Selected Backup"

    local earliest_formatted=""
    local latest_formatted=""

    if [ -n "$BACKUP_COMPLETED" ]; then
        earliest_formatted=$(echo "$BACKUP_COMPLETED" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
    fi
    if [ -n "$BACKUP_LATEST" ]; then
        latest_formatted=$(echo "$BACKUP_LATEST" | sed 's/T/ /g' | sed 's/Z//g' | cut -c1-19)
    fi

    if [ -n "$earliest_formatted" ] && [ -n "$latest_formatted" ]; then
        echo -e "  ${CYAN}Earliest (backup completed):${NC}  ${earliest_formatted} UTC"
        echo -e "  ${CYAN}Latest (binlogs available):${NC}   ${latest_formatted} UTC"
        echo ""
        echo "  You can restore to any point in time between these two timestamps."
        echo "  The earliest time is when the backup completed."
        echo "  The latest time is based on available binlogs (latestRestorableTime)."
    elif [ -n "$earliest_formatted" ]; then
        echo -e "  ${CYAN}Backup completed:${NC} ${earliest_formatted} UTC"
        echo ""
        log_warn "No latestRestorableTime available - PITR may not be enabled for this backup."
        echo "  You can restore to the backup completion time only."
        latest_formatted="$earliest_formatted"
    else
        log_error "Cannot determine restorable time window for this backup."
        exit 1
    fi

    echo ""
    echo -e "  ${BOLD}Required format: YYYY-MM-DD HH:MM:SS${NC}"
    echo ""

    # Get restore time
    if [ -z "$RESTORE_TIME" ]; then
        local default_time="${latest_formatted:-}"

        echo -n "Enter restore time [${default_time}]: "
        read -r input_time
        RESTORE_TIME="${input_time:-$default_time}"
    fi

    # Validate time format
    if [ -n "$RESTORE_TIME" ]; then
        if ! [[ "$RESTORE_TIME" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
            log_error "Invalid time format. Use: YYYY-MM-DD HH:MM:SS"
            exit 1
        fi
        
        # Validate time is within the window
        if [ -n "$earliest_formatted" ] && [ -n "$latest_formatted" ]; then
            if [[ "$RESTORE_TIME" < "$earliest_formatted" ]]; then
                log_error "Restore time is before the backup completion time ($earliest_formatted)"
                exit 1
            fi
            if [[ "$RESTORE_TIME" > "$latest_formatted" ]]; then
                log_error "Restore time is after the latest restorable time ($latest_formatted)"
                log_error "Binlogs are not available beyond this point."
                exit 1
            fi
        fi
        
        log_success "Restore time: ${RESTORE_TIME} UTC"
    else
        log_error "Restore time is required"
        exit 1
    fi
}

# Validate and/or create target namespace
setup_target_namespace() {
    log_header "Target Namespace"
    echo ""
    echo "The restore will create a NEW cluster in a target namespace."
    echo "The source namespace (${SOURCE_NAMESPACE}) will NOT be modified."
    echo ""

    while true; do
        if [ -z "$TARGET_NAMESPACE" ]; then
            echo -n "Enter target namespace: "
            read -r TARGET_NAMESPACE
        fi

        if [ -z "$TARGET_NAMESPACE" ]; then
            log_warn "Target namespace cannot be empty"
            TARGET_NAMESPACE=""
            continue
        fi

        if [ "$TARGET_NAMESPACE" = "$SOURCE_NAMESPACE" ]; then
            log_warn "Cannot restore to the source namespace"
            TARGET_NAMESPACE=""
            continue
        fi

        # Validate namespace name
        if ! [[ "$TARGET_NAMESPACE" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
            log_warn "Invalid namespace name. Use lowercase letters, numbers, and hyphens."
            TARGET_NAMESPACE=""
            continue
        fi

        # Check if namespace exists
        if kctl get namespace "$TARGET_NAMESPACE" &>/dev/null; then
            # Check if it has a PXC cluster
            local existing_cluster
            existing_cluster=$(get_cluster_name "$TARGET_NAMESPACE")
            if [ -n "$existing_cluster" ]; then
                log_warn "Namespace already contains PXC cluster: $existing_cluster"
                echo -n "Continue anyway? [y/N]: "
                read -r continue_anyway
                if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
                    TARGET_NAMESPACE=""
                    continue
                fi
            else
                log_success "Namespace exists and has no PXC cluster"
            fi
            break
        else
            echo ""
            echo -n "Namespace does not exist. Create it? [Y/n]: "
            read -r create_ns

            if [[ ! "$create_ns" =~ ^[Nn]$ ]]; then
                if [ "$DRY_RUN" = true ]; then
                    log_dry "Would create namespace: $TARGET_NAMESPACE"
                else
                    log_info "Creating namespace: $TARGET_NAMESPACE"
                    if kctl create namespace "$TARGET_NAMESPACE"; then
                        log_success "Namespace created"
                    else
                        log_error "Failed to create namespace"
                        TARGET_NAMESPACE=""
                        continue
                    fi
                fi
                break
            else
                TARGET_NAMESPACE=""
            fi
        fi
    done
}

# Copy a secret from source to target namespace
copy_secret() {
    local secret_name="$1"
    local source_ns="$2"
    local target_ns="$3"

    if ! kctl get secret "$secret_name" -n "$source_ns" &>/dev/null; then
        log_warn "Secret not found: $secret_name in $source_ns"
        return 1
    fi

    if [ "$DRY_RUN" = true ]; then
        log_dry "Would copy secret: $secret_name from $source_ns to $target_ns"
        return 0
    fi

    # Get secret and modify for target namespace
    local secret_json
    secret_json=$(kctl get secret "$secret_name" -n "$source_ns" -o json)

    # Remove metadata fields that shouldn't be copied
    secret_json=$(echo "$secret_json" | jq --arg ns "$target_ns" '
        .metadata.namespace = $ns |
        del(.metadata.resourceVersion) |
        del(.metadata.uid) |
        del(.metadata.creationTimestamp) |
        del(.metadata.managedFields) |
        del(.metadata.ownerReferences)
    ')

    # Apply to target namespace
    if echo "$secret_json" | kctl apply -f - &>/dev/null; then
        log_success "Copied secret: $secret_name"
        return 0
    else
        log_warn "Failed to copy secret: $secret_name"
        return 1
    fi
}

# Create target cluster based on source
create_target_cluster() {
    local source_ns="$1"
    local target_ns="$2"
    local source_cluster="$3"
    local target_cluster="${source_cluster}-restored"

    log_header "Creating Target Cluster"

    # Get source cluster spec
    local source_json
    source_json=$(kctl get perconaxtradbcluster "$source_cluster" -n "$source_ns" -o json)

    if [ -z "$source_json" ]; then
        log_error "Failed to get source cluster spec"
        return 1
    fi

    # Copy required secrets
    log_info "Copying secrets to target namespace..."

    # Get secrets name from spec or use default
    local secrets_name
    secrets_name=$(echo "$source_json" | jq -r '.spec.secretsName // ""')
    if [ -z "$secrets_name" ]; then
        secrets_name="${source_cluster}-secrets"
    fi
    copy_secret "$secrets_name" "$source_ns" "$target_ns" || true

    # Copy backup credentials
    local backup_creds
    backup_creds=$(echo "$source_json" | jq -r '.spec.backup.storages[]?.s3?.credentialsSecret // empty' | head -1)
    if [ -n "$backup_creds" ]; then
        copy_secret "$backup_creds" "$source_ns" "$target_ns" || true
    fi

    # Modify cluster spec for target
    local target_json
    target_json=$(echo "$source_json" | jq --arg name "$target_cluster" --arg ns "$target_ns" '
        .metadata.name = $name |
        .metadata.namespace = $ns |
        del(.metadata.resourceVersion) |
        del(.metadata.uid) |
        del(.metadata.creationTimestamp) |
        del(.metadata.generation) |
        del(.metadata.managedFields) |
        del(.metadata.ownerReferences) |
        del(.status)
    ')

    if [ "$DRY_RUN" = true ]; then
        log_dry "Would create PXC cluster: $target_cluster in namespace $target_ns"
        log_dry "Cluster spec based on: $source_cluster"
        if [ "$VERBOSE" = true ]; then
            echo ""
            echo "Target cluster spec (abbreviated):"
            echo "$target_json" | jq '{apiVersion, kind, metadata: {name: .metadata.name, namespace: .metadata.namespace}, spec: {pxc: {size: .spec.pxc.size}, proxysql: {size: .spec.proxysql.size}}}'
        fi
        return 0
    fi

    log_info "Creating PXC cluster: $target_cluster"

    # Write to temp file and apply
    local tmp_file
    tmp_file=$(mktemp)
    echo "$target_json" > "$tmp_file"

    if kctl apply -f "$tmp_file"; then
        log_success "Cluster created: $target_cluster"
        rm -f "$tmp_file"
        return 0
    else
        log_error "Failed to create cluster"
        rm -f "$tmp_file"
        return 1
    fi
}

# Create restore resource
create_restore() {
    local target_ns="$1"
    local target_cluster="$2"
    local backup_name="$3"
    local restore_time="$4"
    local storage_name="$5"

    local restore_name="restore-${target_cluster}-$(date +%s)"

    log_header "Creating Restore Resource"

    local restore_yaml
    restore_yaml=$(cat <<EOF
apiVersion: pxc.percona.com/v1
kind: PerconaXtraDBClusterRestore
metadata:
  name: ${restore_name}
  namespace: ${target_ns}
spec:
  pxcCluster: ${target_cluster}
  backupName: ${backup_name}
  pitr:
    type: date
    date: "${restore_time}"
    backupSource:
      storageName: ${storage_name}
EOF
)

    if [ "$DRY_RUN" = true ]; then
        log_dry "Would create restore resource:"
        echo ""
        echo "$restore_yaml"
        echo ""
        RESTORE_NAME="$restore_name"
        return 0
    fi

    log_info "Creating restore: $restore_name"

    if echo "$restore_yaml" | kctl apply -f -; then
        log_success "Restore resource created"
        RESTORE_NAME="$restore_name"
        return 0
    else
        log_error "Failed to create restore resource"
        return 1
    fi
}

# Wait for restore to complete
wait_for_restore() {
    local target_ns="$1"
    local restore_name="$2"
    local target_cluster="$3"

    log_header "Waiting for Restore"
    log_info "This may take several minutes..."
    echo ""

    local max_attempts=120  # 10 minutes with 5 second intervals
    local attempt=0
    local last_state=""

    while [ $attempt -lt $max_attempts ]; do
        ((attempt++))

        # Get restore status
        local restore_state
        restore_state=$(kctl get perconaxtradbclusterrestore "$restore_name" -n "$target_ns" -o jsonpath='{.status.state}' 2>/dev/null || echo "Pending")

        # Get cluster status
        local cluster_state pxc_ready pxc_size
        cluster_state=$(kctl get perconaxtradbcluster "$target_cluster" -n "$target_ns" -o jsonpath='{.status.state}' 2>/dev/null || echo "initializing")
        pxc_ready=$(kctl get perconaxtradbcluster "$target_cluster" -n "$target_ns" -o jsonpath='{.status.pxc.ready}' 2>/dev/null || echo "0")
        pxc_size=$(kctl get perconaxtradbcluster "$target_cluster" -n "$target_ns" -o jsonpath='{.status.pxc.size}' 2>/dev/null || echo "?")

        # Update display
        printf "\r  Restore: %-15s | Cluster: %-15s | Nodes: %s/%s    " "$restore_state" "$cluster_state" "$pxc_ready" "$pxc_size"

        # Check completion
        if [ "$restore_state" = "Succeeded" ] || [ "$restore_state" = "Ready" ]; then
            if [ "$cluster_state" = "ready" ]; then
                echo ""
                log_success "Restore completed successfully!"
                return 0
            fi
        elif [ "$restore_state" = "Failed" ] || [ "$restore_state" = "Error" ]; then
            echo ""
            local message
            message=$(kctl get perconaxtradbclusterrestore "$restore_name" -n "$target_ns" -o jsonpath='{.status.comments}' 2>/dev/null || echo "Unknown error")
            log_error "Restore failed: $message"
            return 1
        fi

        sleep 5
    done

    echo ""
    log_error "Restore timed out after 10 minutes"
    log_info "Check status: kubectl get pxc-restore $restore_name -n $target_ns"
    return 1
}

# Get database summary
get_database_summary() {
    local target_ns="$1"
    local target_cluster="$2"

    log_header "Database Summary"

    # Get root password
    local secrets_name="${target_cluster}-secrets"
    local root_pwd_b64
    root_pwd_b64=$(kctl get secret "$secrets_name" -n "$target_ns" -o jsonpath='{.data.root}' 2>/dev/null || echo "")

    if [ -z "$root_pwd_b64" ]; then
        log_warn "Could not get root password from secret"
        echo ""
        echo "  Connect manually to view databases:"
        echo -e "  ${CYAN}kubectl exec -it ${target_cluster}-pxc-0 -n ${target_ns} -c pxc -- mysql -uroot -p${NC}"
        return
    fi

    local root_pwd
    root_pwd=$(echo "$root_pwd_b64" | base64 -d 2>/dev/null || echo "")

    if [ -z "$root_pwd" ]; then
        log_warn "Could not decode root password"
        return
    fi

    # Get databases and table counts
    local pod_name="${target_cluster}-pxc-0"
    local db_query="SELECT SCHEMA_NAME FROM information_schema.SCHEMATA WHERE SCHEMA_NAME NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')"

    local databases
    databases=$(kctl exec -n "$target_ns" "$pod_name" -c pxc -- mysql -uroot -p"$root_pwd" -N -e "$db_query" 2>/dev/null || echo "")

    if [ -z "$databases" ]; then
        echo "  No user databases found (only system databases exist)."
    else
        printf "  %-30s %s\n" "DATABASE" "TABLES"
        printf "  %s\n" "----------------------------------------"

        local total_tables=0
        while IFS= read -r db; do
            db=$(echo "$db" | tr -d '\r' | xargs)
            if [ -n "$db" ]; then
                local table_count
                table_count=$(kctl exec -n "$target_ns" "$pod_name" -c pxc -- mysql -uroot -p"$root_pwd" -N -e "SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA = '$db'" 2>/dev/null || echo "0")
                table_count=$(echo "$table_count" | tr -d '\r' | xargs)
                printf "  %-30s %s\n" "$db" "$table_count"
                total_tables=$((total_tables + table_count))
            fi
        done <<< "$databases"

        printf "  %s\n" "----------------------------------------"
        printf "  %-30s %s\n" "TOTAL" "$total_tables"
    fi

    echo ""
    echo "  Connect to the restored cluster:"
    echo -e "  ${CYAN}kubectl exec -it ${target_cluster}-pxc-0 -n ${target_ns} -c pxc -- mysql -uroot -p${NC}"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            SOURCE_NAMESPACE="$2"
            shift 2
            ;;
        -t|--target)
            TARGET_NAMESPACE="$2"
            shift 2
            ;;
        -b|--backup)
            BACKUP_NAME="$2"
            shift 2
            ;;
        -r|--restore-time)
            RESTORE_TIME="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --kubeconfig)
            KUBECONFIG="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            echo ""
            usage
            ;;
    esac
done

# Validate required arguments
if [ -z "$SOURCE_NAMESPACE" ]; then
    log_error "Source namespace is required. Use -n or --namespace."
    echo ""
    usage
fi

# Main execution
log_header "PXC Point-in-Time Restore"

if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}*** DRY RUN MODE - No changes will be made ***${NC}"
    echo ""
fi

# Check prerequisites
if ! check_prerequisites; then
    exit 1
fi

# Get cluster name
CLUSTER_NAME=$(get_cluster_name "$SOURCE_NAMESPACE")
if [ -z "$CLUSTER_NAME" ]; then
    log_error "No PXC cluster found in namespace: $SOURCE_NAMESPACE"
    exit 1
fi

log_info "Source cluster: $CLUSTER_NAME"

# List and select backup
display_and_select_backup "$SOURCE_NAMESPACE"

# Setup target namespace
setup_target_namespace

# Show summary
TARGET_CLUSTER="${CLUSTER_NAME}-restored"

log_header "Restore Summary"
echo ""
echo -e "  ${CYAN}Source Namespace:${NC}  ${SOURCE_NAMESPACE}"
echo -e "  ${CYAN}Source Cluster:${NC}    ${CLUSTER_NAME}"
echo -e "  ${CYAN}Backup:${NC}            ${BACKUP_NAME}"
echo -e "  ${CYAN}Restore To:${NC}        ${RESTORE_TIME} UTC"
echo -e "  ${CYAN}Target Namespace:${NC}  ${TARGET_NAMESPACE}"
echo -e "  ${CYAN}New Cluster Name:${NC}  ${TARGET_CLUSTER}"
echo ""

if [ "$DRY_RUN" = true ]; then
    log_header "Dry Run - Detailed Validation"
    
    local dry_errors=0
    
    # Validate secrets that will be copied
    echo "Validating secrets to copy:"
    
    local secrets_name
    secrets_name=$(kctl get perconaxtradbcluster "$CLUSTER_NAME" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.secretsName}' 2>/dev/null || echo "")
    if [ -z "$secrets_name" ]; then
        secrets_name="${CLUSTER_NAME}-secrets"
    fi
    
    if kctl get secret "$secrets_name" -n "$SOURCE_NAMESPACE" &>/dev/null; then
        log_dry "  Will copy cluster secret: $secrets_name"
    else
        log_error "  Cluster secret not found: $secrets_name"
        ((dry_errors++))
    fi
    
    # Check backup credentials
    local backup_creds
    backup_creds=$(kctl get perconaxtradbcluster "$CLUSTER_NAME" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.backup.storages[]?.s3?.credentialsSecret // empty' | head -1)
    if [ -n "$backup_creds" ]; then
        if kctl get secret "$backup_creds" -n "$SOURCE_NAMESPACE" &>/dev/null; then
            log_dry "  Will copy backup credentials: $backup_creds"
        else
            log_error "  Backup credentials secret not found: $backup_creds"
            ((dry_errors++))
        fi
    fi
    echo ""
    
    # Validate backup storage name matches cluster config
    echo "Validating backup configuration:"
    local storage_names
    storage_names=$(kctl get perconaxtradbcluster "$CLUSTER_NAME" -n "$SOURCE_NAMESPACE" -o json 2>/dev/null | jq -r '.spec.backup.storages | keys[]' 2>/dev/null || echo "")
    
    if echo "$storage_names" | grep -q "^${BACKUP_STORAGE}$"; then
        log_dry "  Backup storage '$BACKUP_STORAGE' exists in cluster config"
    else
        log_error "  Backup storage '$BACKUP_STORAGE' not found in cluster config"
        log_error "  Available storages: $storage_names"
        ((dry_errors++))
    fi
    
    # Verify backup exists and is accessible
    local backup_state backup_destination
    backup_state=$(kctl get perconaxtradbclusterbackup "$BACKUP_NAME" -n "$SOURCE_NAMESPACE" -o jsonpath='{.status.state}' 2>/dev/null || echo "")
    backup_destination=$(kctl get perconaxtradbclusterbackup "$BACKUP_NAME" -n "$SOURCE_NAMESPACE" -o jsonpath='{.status.destination}' 2>/dev/null || echo "")
    
    if [ "$backup_state" = "Succeeded" ] || [ "$backup_state" = "Ready" ]; then
        log_dry "  Backup '$BACKUP_NAME' is in $backup_state state"
        if [ -n "$backup_destination" ]; then
            log_dry "  Backup location: $backup_destination"
        fi
    else
        log_error "  Backup '$BACKUP_NAME' is not in Succeeded state (current: ${backup_state:-unknown})"
        ((dry_errors++))
    fi
    echo ""
    
    # Validate target namespace
    echo "Validating target namespace:"
    if kctl get namespace "$TARGET_NAMESPACE" &>/dev/null; then
        log_dry "  Target namespace '$TARGET_NAMESPACE' exists"
        
        # Check for existing cluster with same name
        local existing_cluster
        existing_cluster=$(kctl get perconaxtradbcluster "$TARGET_CLUSTER" -n "$TARGET_NAMESPACE" 2>/dev/null && echo "exists" || echo "")
        if [ "$existing_cluster" = "exists" ]; then
            log_error "  Cluster '$TARGET_CLUSTER' already exists in target namespace"
            ((dry_errors++))
        else
            log_dry "  No conflicting cluster named '$TARGET_CLUSTER'"
        fi
    else
        log_dry "  Target namespace '$TARGET_NAMESPACE' will be created"
    fi
    echo ""
    
    # Show cluster spec that will be created
    echo "Cluster configuration to create:"
    local pxc_size proxysql_size
    pxc_size=$(kctl get perconaxtradbcluster "$CLUSTER_NAME" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.pxc.size}' 2>/dev/null || echo "?")
    proxysql_size=$(kctl get perconaxtradbcluster "$CLUSTER_NAME" -n "$SOURCE_NAMESPACE" -o jsonpath='{.spec.proxysql.size}' 2>/dev/null || echo "?")
    log_dry "  PXC nodes: $pxc_size"
    log_dry "  ProxySQL nodes: $proxysql_size"
    echo ""
    
    # Show restore configuration
    echo "Restore configuration:"
    log_dry "  Backup: $BACKUP_NAME"
    log_dry "  Restore time: $RESTORE_TIME"
    log_dry "  Storage: $BACKUP_STORAGE"
    echo ""
    
    log_header "Dry Run - Actions Summary"
    echo ""
    log_dry "1. Copy secrets from $SOURCE_NAMESPACE to $TARGET_NAMESPACE"
    log_dry "   - $secrets_name (cluster secrets)"
    if [ -n "$backup_creds" ]; then
        log_dry "   - $backup_creds (backup credentials)"
    fi
    log_dry "2. Create PXC cluster $TARGET_CLUSTER in $TARGET_NAMESPACE"
    log_dry "   - $pxc_size PXC nodes, $proxysql_size ProxySQL nodes"
    log_dry "3. Create PerconaXtraDBClusterRestore resource"
    log_dry "   - Restore from backup: $BACKUP_NAME"
    log_dry "   - Point-in-time: $RESTORE_TIME UTC"
    log_dry "4. Wait for restore completion and cluster ready state"
    log_dry "5. Display database summary"
    echo ""
    
    if [ $dry_errors -gt 0 ]; then
        log_error "Dry run validation failed with $dry_errors error(s)"
        log_error "Fix the issues above before running without --dry-run"
        exit 1
    fi
    
    log_success "Dry run validation complete. All checks passed."
    log_info "Remove --dry-run to perform the actual restore."
    exit 0
fi

echo -e "${YELLOW}WARNING: This will create a new PXC cluster in the target namespace.${NC}"
echo -e "${YELLOW}         The source cluster and namespace will NOT be modified.${NC}"
echo ""
echo -n "Proceed with restore? [y/N]: "
read -r confirm

if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    log_info "Restore cancelled"
    exit 0
fi

# Execute restore
create_target_cluster "$SOURCE_NAMESPACE" "$TARGET_NAMESPACE" "$CLUSTER_NAME" || exit 1

# Wait a moment for cluster to be registered
sleep 5

create_restore "$TARGET_NAMESPACE" "$TARGET_CLUSTER" "$BACKUP_NAME" "$RESTORE_TIME" "$BACKUP_STORAGE" || exit 1

wait_for_restore "$TARGET_NAMESPACE" "$RESTORE_NAME" "$TARGET_CLUSTER" || exit 1

get_database_summary "$TARGET_NAMESPACE" "$TARGET_CLUSTER"

echo ""
log_success "Restore completed successfully!"
