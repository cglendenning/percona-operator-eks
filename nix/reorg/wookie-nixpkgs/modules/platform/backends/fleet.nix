# Fleet backend for Kubernetes platform
# Generates Fleet Bundle CRDs instead of direct kubectl apply
{
  pkgs,
  lib,
  config,
  ...
}:
with lib;

let
  cfg = config.platform.kubernetes;
  
  # Generate a Fleet Bundle CRD for a batch
  generateFleetBundle = batchName: batchConfig: bundleList:
    let
      yaml = pkgs.formats.yaml { };
      
      # Combine all bundle manifests in this batch
      bundleContent = lib.concatMapStringsSep "\n---\n" (bundle: 
        builtins.readFile "${bundle}/manifest.yaml"
      ) bundleList;
      
      # Check content size (Fleet has 262KB annotation limit)
      contentSize = builtins.stringLength bundleContent;
      tooLarge = contentSize > 200000; # Skip Fleet for batches > 200KB
      
      # Create Fleet Bundle CRD (only if not too large)
      fleetBundle = {
        apiVersion = "fleet.cattle.io/v1alpha1";
        kind = "Bundle";
        metadata = {
          name = "${cfg.cluster.uniqueIdentifier}-${batchName}";
          namespace = "fleet-local";
          labels = {
            "batch" = batchName;
            "cluster" = cfg.cluster.uniqueIdentifier;
          };
        };
        spec = {
          # Dependencies on previous batches
          dependsOn = map (dep: { name = "${cfg.cluster.uniqueIdentifier}-${dep}"; }) batchConfig.dependsOn;
          
          # Target all clusters (can be refined with selectors)
          targets = [
            { clusterSelector = { }; }
          ];
          
          # Inline manifest content
          resources = [
            {
              name = batchName;
              content = bundleContent;
            }
          ];
          
          # Fleet-specific options
          helm = null;  # We're using raw manifests, not Helm
        };
      };
    in
    {
      bundle = if tooLarge then null else yaml.generate "${batchName}-bundle.yaml" fleetBundle;
      manifest = pkgs.writeText "${batchName}-manifest.yaml" bundleContent;
      tooLarge = tooLarge;
      batchName = batchName;
    };

  # Generate all Fleet bundles for the cluster
  generateAllFleetBundles = clusterConfig:
    let
      batches = clusterConfig.platform.kubernetes.cluster.batches;
      
      # Get sorted batches (by priority)
      sortedBatches = lib.sort 
        (a: b: batches.${a}.priority < batches.${b}.priority)
        (lib.attrNames batches);
      
      # Generate Fleet Bundle for each batch
      fleetBundles = map (batchName:
        let
          batchConfig = batches.${batchName};
          
          # Get enabled bundles for this batch
          enabledBundles = lib.filter (b: b.enabled or true) 
            (lib.attrValues batchConfig.bundles);
          
          # Render each bundle to manifests
          bundleList = map pkgs.kubelib.renderBundle enabledBundles;
        in
        {
          name = batchName;
          bundle = generateFleetBundle batchName batchConfig bundleList;
        }
      ) sortedBatches;
    in
    fleetBundles;

in
{
  options.platform.kubernetes.backend.fleet = {
    enable = mkOption {
      type = types.bool;
      default = true;
      description = "Enable Fleet backend for Kubernetes deployments";
    };
    
    namespace = mkOption {
      type = types.str;
      default = "fleet-local";
      description = "Fleet namespace to deploy bundles to";
    };
    
    autoInstall = mkOption {
      type = types.bool;
      default = true;
      description = "Automatically install Fleet if not present";
    };
    
    helmChart = mkOption {
      type = types.submodule {
        options = {
          repo = mkOption {
            type = types.str;
            default = "https://rancher.github.io/fleet-helm-charts/";
            description = "Fleet Helm chart repository";
          };
          
          version = mkOption {
            type = types.str;
            default = "latest";
            description = "Fleet Helm chart version";
          };
        };
      };
      default = {};
      description = "Fleet Helm chart configuration";
    };
  };

  config = mkIf cfg.backend.fleet.enable {
    # Add Fleet bundle generation to the build outputs
    build = {
      # Generate fleet.yaml with all bundles
      fleet-bundles = pkgs.runCommand "${cfg.cluster.uniqueIdentifier}-fleet-bundles" { } ''
        mkdir -p $out
        
        # Generate header
        cat > $out/fleet.yaml << 'EOF'
# Fleet Bundles for ${cfg.cluster.uniqueIdentifier}
# 
# Generated by Nix from platform configuration
# Deploy with: kubectl apply -f fleet.yaml
#
# Monitor with: kubectl get bundles -n ${cfg.backend.fleet.namespace}
EOF
        
        # Add each bundle
        ${lib.concatMapStringsSep "\n" (bundle: ''
          echo "---" >> $out/fleet.yaml
          cat ${bundle.bundle} >> $out/fleet.yaml
        '') (generateAllFleetBundles config)}
      '';
      
      # Generate Fleet deployment script
      scripts.deploy-fleet = pkgs.writeShellApplication {
        name = "deploy-${cfg.cluster.uniqueIdentifier}-fleet";
        runtimeInputs = [ pkgs.kubectl pkgs.kubernetes-helm ];
        text = ''
          set -euo pipefail
          
          CONTEXT="''${CLUSTER_CONTEXT:-${cfg.cluster.uniqueIdentifier}}"
          FLEET_NS="${cfg.backend.fleet.namespace}"
          
          echo "=== Deploying ${cfg.cluster.uniqueIdentifier} via Fleet ==="
          echo ""
          
          ${optionalString cfg.backend.fleet.autoInstall ''
          # Install or upgrade Fleet
          if ! helm list -n fleet-system --kube-context "$CONTEXT" 2>/dev/null | grep -q "^fleet"; then
            echo "Installing Fleet..."
            helm repo add fleet ${cfg.backend.fleet.helmChart.repo} 2>/dev/null || true
            helm repo update
            
            echo "Installing Fleet CRDs..."
            helm upgrade --install fleet-crd fleet/fleet-crd \
              --namespace fleet-system \
              --create-namespace \
              --wait \
              --kube-context "$CONTEXT"
            
            echo "Installing Fleet controller..."
            helm upgrade --install fleet fleet/fleet \
              --namespace fleet-system \
              --create-namespace \
              --wait \
              --timeout 5m \
              --kube-context "$CONTEXT" \
              ${optionalString (cfg.backend.fleet.helmChart.version != "latest") 
                "--version ${cfg.backend.fleet.helmChart.version}"}
            echo "Fleet installed successfully"
            echo ""
          else
            echo "Fleet already installed"
            echo ""
          fi
          ''}
          
          # Apply Fleet bundles
          echo "Applying Fleet bundles..."
          kubectl apply -f ${config.build.fleet-bundles}/fleet.yaml --context "$CONTEXT"
          
          echo ""
          echo "=== Fleet deployment complete ==="
          echo ""
          echo "Monitor deployment:"
          echo "  kubectl get bundles -n $FLEET_NS --context $CONTEXT"
          echo "  kubectl get bundledeployments -n $FLEET_NS --context $CONTEXT"
          echo ""
          echo "Check resources:"
          echo "  kubectl get all -n istio-system --context $CONTEXT"
        '';
      };
      
      # Generate status check script
      scripts.fleet-status = pkgs.writeShellApplication {
        name = "fleet-status-${cfg.cluster.uniqueIdentifier}";
        runtimeInputs = [ pkgs.kubectl ];
        text = ''
          CONTEXT="''${CLUSTER_CONTEXT:-${cfg.cluster.uniqueIdentifier}}"
          FLEET_NS="${cfg.backend.fleet.namespace}"
          
          echo "=== Fleet Bundles ==="
          kubectl get bundles -n "$FLEET_NS" --context "$CONTEXT"
          
          echo ""
          echo "=== Bundle Deployments ==="
          kubectl get bundledeployments -n "$FLEET_NS" --context "$CONTEXT"
          
          echo ""
          echo "=== Istio Resources ==="
          kubectl get all -n istio-system --context "$CONTEXT"
        '';
      };
    };
  };
}
